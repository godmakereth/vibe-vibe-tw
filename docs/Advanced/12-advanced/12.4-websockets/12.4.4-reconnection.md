---
title: "12.4.4 處理連接異常——連接管理：斷線重連與狀態同步"
typora-root-url: ../../public
---

# 12.4.4 處理連接異常——連接管理：斷線重連與狀態同步

### 一句話破題

網絡不可靠是常態，優秀的即時應用必須優雅地處理斷線、重連和狀態同步。

### 連接狀態管理

```tsx
'use client';

import { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'reconnecting';

export function useSocket(url: string) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [status, setStatus] = useState<ConnectionStatus>('connecting');

  useEffect(() => {
    const newSocket = io(url, {
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    });

    newSocket.on('connect', () => {
      setStatus('connected');
      console.log('已連接');
    });

    newSocket.on('disconnect', (reason) => {
      setStatus('disconnected');
      console.log('斷開連接:', reason);
    });

    newSocket.on('reconnect_attempt', (attempt) => {
      setStatus('reconnecting');
      console.log(`重連嘗試 ${attempt}`);
    });

    newSocket.on('reconnect', () => {
      setStatus('connected');
      console.log('重連成功');
    });

    newSocket.on('reconnect_failed', () => {
      setStatus('disconnected');
      console.log('重連失敗');
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, [url]);

  return { socket, status };
}
```

### 連接狀態 UI

```tsx
function ConnectionIndicator({ status }: { status: ConnectionStatus }) {
  const config = {
    connecting: { color: 'bg-yellow-500', text: '連接中...' },
    connected: { color: 'bg-green-500', text: '已連接' },
    disconnected: { color: 'bg-red-500', text: '已斷開' },
    reconnecting: { color: 'bg-orange-500', text: '重連中...' },
  };

  const { color, text } = config[status];

  return (
    <div className="flex items-center gap-2">
      <span className={`w-2 h-2 rounded-full ${color}`} />
      <span className="text-sm text-gray-600">{text}</span>
    </div>
  );
}
```

### 狀態同步策略

斷線重連後，需要同步期間錯過的狀態：

```typescript
// 服務端：記錄消息歷史
const messageHistory = new Map<string, Message[]>();

io.on('connection', (socket) => {
  socket.on('joinRoom', (roomId: string) => {
    socket.join(roomId);
    
    // 發送歷史消息
    const history = messageHistory.get(roomId) || [];
    socket.emit('messageHistory', history.slice(-50)); // 最近 50 條
  });

  socket.on('sendMessage', ({ roomId, content }) => {
    const message = { id: Date.now().toString(), content, timestamp: Date.now() };
    
    // 保存到歷史
    if (!messageHistory.has(roomId)) {
      messageHistory.set(roomId, []);
    }
    messageHistory.get(roomId)!.push(message);
    
    io.to(roomId).emit('newMessage', message);
  });
});

// 客戶端：處理歷史消息
socket.on('messageHistory', (history: Message[]) => {
  setMessages((prev) => {
    // 去重合並
    const existingIds = new Set(prev.map((m) => m.id));
    const newMessages = history.filter((m) => !existingIds.has(m.id));
    return [...newMessages, ...prev].sort((a, b) => a.timestamp - b.timestamp);
  });
});
```

### 心跳機制

Socket.io 內置了心跳機制，但你也可以自定義：

```typescript
// 服務端配置
const io = new Server(httpServer, {
  pingTimeout: 60000,    // 等待 pong 響應的超時時間
  pingInterval: 25000,   // 發送 ping 的間隔
});

// 客戶端可以監聽
socket.on('ping', () => {
  console.log('收到心跳');
});
```

### 離線消息隊列

網絡不好時，先緩存消息，恢復後再發送：

```typescript
class MessageQueue {
  private queue: Array<{ event: string; data: unknown }> = [];
  private socket: Socket | null = null;

  setSocket(socket: Socket) {
    this.socket = socket;
    this.flush();
  }

  send(event: string, data: unknown) {
    if (this.socket?.connected) {
      this.socket.emit(event, data);
    } else {
      this.queue.push({ event, data });
    }
  }

  flush() {
    if (this.socket?.connected) {
      while (this.queue.length > 0) {
        const { event, data } = this.queue.shift()!;
        this.socket.emit(event, data);
      }
    }
  }
}
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你實現健壯的連接管理。
- **需求定義公式**：`"請幫我實現一個帶有連接狀態顯示、自動重連和離線消息隊列的 Socket.io 客戶端封裝。"`
- **關鍵術語**：`重連 (reconnection)`、`心跳 (heartbeat)`、`狀態同步`、`離線隊列`

### 避坑指南

- **指數退避**：重連間隔應該逐漸增加，避免服務器過載。
- **最大重試次數**：不要無限重試，給用戶反饋讓他們手動刷新。
- **冪等性**：重發的消息不應該產生副作用（如重複扣款）。
