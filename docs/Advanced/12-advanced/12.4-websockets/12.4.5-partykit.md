---
title: "12.4.5 現代化選擇——PartyKit：邊緣計算的即時通信方案"
typora-root-url: ../../public
---

# 12.4.5 現代化選擇——PartyKit：邊緣計算的即時通信方案

### 一句話破題

PartyKit 是"邊緣優先"的即時通信平臺，它讓你用最少的代碼構建全球分佈式的即時應用。

### 爲什麼選擇 PartyKit

傳統 WebSocket 服務器的問題：

- **單點部署**：用戶距離服務器越遠，延遲越高
- **擴展困難**：需要自己處理負載均衡和狀態同步
- **運維負擔**：需要管理服務器、監控、日誌等

PartyKit 的解決方案：

- **邊緣部署**：代碼自動部署到全球各地的邊緣節點
- **零運維**：完全託管，無需關心基礎設施
- **狀態管理**：內置持久化存儲和狀態同步

### 快速上手

```bash
# 安裝 CLI
npm install -g partykit

# 創建項目
npx create-partykit my-party
cd my-party
```

#### 服務端代碼

```typescript
// party/index.ts
import type { PartyKitServer, PartyKitConnection, PartyKitRoom } from 'partykit/server';

export default {
  onConnect(connection: PartyKitConnection, room: PartyKitRoom) {
    console.log(`${connection.id} 加入房間 ${room.id}`);
    
    // 發送歡迎消息
    connection.send(JSON.stringify({ type: 'welcome', roomId: room.id }));
    
    // 廣播給其他人
    room.broadcast(
      JSON.stringify({ type: 'userJoined', id: connection.id }),
      [connection.id] // 排除當前用戶
    );
  },

  onMessage(message: string, connection: PartyKitConnection, room: PartyKitRoom) {
    const data = JSON.parse(message);
    
    // 廣播消息給所有人
    room.broadcast(
      JSON.stringify({
        type: 'message',
        from: connection.id,
        content: data.content,
        timestamp: Date.now(),
      })
    );
  },

  onClose(connection: PartyKitConnection, room: PartyKitRoom) {
    room.broadcast(
      JSON.stringify({ type: 'userLeft', id: connection.id })
    );
  },
} satisfies PartyKitServer;
```

#### 客戶端代碼

```tsx
'use client';

import { useEffect, useState } from 'react';
import PartySocket from 'partysocket';

export default function PartyChat({ roomId }: { roomId: string }) {
  const [messages, setMessages] = useState<Array<{ from: string; content: string }>>([]);
  const [input, setInput] = useState('');
  const [socket, setSocket] = useState<PartySocket | null>(null);

  useEffect(() => {
    const partySocket = new PartySocket({
      host: 'your-project.partykit.dev', // 或 localhost:1999 用於開發
      room: roomId,
    });

    partySocket.addEventListener('message', (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'message') {
        setMessages((prev) => [...prev, { from: data.from, content: data.content }]);
      }
    });

    setSocket(partySocket);

    return () => {
      partySocket.close();
    };
  }, [roomId]);

  const sendMessage = () => {
    if (socket && input.trim()) {
      socket.send(JSON.stringify({ content: input }));
      setInput('');
    }
  };

  return (
    <div>
      {messages.map((msg, i) => (
        <div key={i}>
          <strong>{msg.from}:</strong> {msg.content}
        </div>
      ))}
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
      />
      <button onClick={sendMessage}>發送</button>
    </div>
  );
}
```

### PartyKit vs Socket.io

| 特性 | Socket.io | PartyKit |
|------|-----------|----------|
| 部署方式 | 自託管服務器 | 邊緣託管 |
| 全球延遲 | 取決於服務器位置 | 自動優化 |
| 擴展性 | 需要自己處理 | 自動擴展 |
| 持久化 | 需要外部數據庫 | 內置存儲 |
| 定價 | 服務器成本 | 按使用量付費 |

### 持久化狀態

PartyKit 可以在邊緣存儲狀態：

```typescript
export default {
  async onConnect(connection, room) {
    // 獲取存儲的狀態
    const state = await room.storage.get('messages') || [];
    connection.send(JSON.stringify({ type: 'history', messages: state }));
  },

  async onMessage(message, connection, room) {
    const data = JSON.parse(message);
    
    // 保存到存儲
    const messages = await room.storage.get('messages') || [];
    messages.push({ from: connection.id, content: data.content });
    await room.storage.put('messages', messages.slice(-100)); // 保留最近 100 條
    
    room.broadcast(message);
  },
} satisfies PartyKitServer;
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你使用 PartyKit 構建即時功能。
- **需求定義公式**：`"請幫我用 PartyKit 實現一個即時協作白板，支持多人同時繪圖和狀態同步。"`
- **關鍵術語**：`PartyKit`、`邊緣計算 (edge computing)`、`room`、`broadcast`、`持久化存儲`

### 避坑指南

- **房間 ID 設計**：房間 ID 決定了用戶分組，設計時要考慮業務邏輯。
- **消息大小限制**：單條消息有大小限制，大數據考慮分片傳輸。
- **冷啓動延遲**：首次連接可能有短暫延遲，做好 loading 狀態處理。
