---
title: "12.4.3 構建在線聊天室——即時消息傳遞：房間管理與消息廣播"
typora-root-url: ../../public
---

# 12.4.3 構建在線聊天室——即時消息傳遞：房間管理與消息廣播

### 一句話破題

房間機制讓你可以把用戶分組，只向特定羣組廣播消息——這是構建多聊天室應用的基礎。

### 房間管理

```typescript
// 服務端
io.on('connection', (socket) => {
  // 加入房間
  socket.on('joinRoom', (roomId: string) => {
    socket.join(roomId);
    socket.to(roomId).emit('userJoined', { userId: socket.id });
    console.log(`${socket.id} 加入房間 ${roomId}`);
  });

  // 離開房間
  socket.on('leaveRoom', (roomId: string) => {
    socket.leave(roomId);
    socket.to(roomId).emit('userLeft', { userId: socket.id });
  });

  // 發送消息到房間
  socket.on('roomMessage', ({ roomId, message }) => {
    io.to(roomId).emit('roomMessage', {
      userId: socket.id,
      message,
      timestamp: Date.now(),
    });
  });
});
```

### 廣播方式對比

```typescript
// 發送給所有人（包括自己）
io.emit('event', data);

// 發送給所有人（除了自己）
socket.broadcast.emit('event', data);

// 發送給特定房間所有人
io.to('roomId').emit('event', data);

// 發送給特定房間（除了自己）
socket.to('roomId').emit('event', data);

// 發送給特定用戶
io.to(socketId).emit('event', data);
```

### 完整聊天室實現

#### 服務端

```typescript
interface Message {
  id: string;
  userId: string;
  username: string;
  content: string;
  timestamp: number;
}

interface Room {
  id: string;
  name: string;
  users: Set<string>;
}

const rooms = new Map<string, Room>();
const users = new Map<string, { socketId: string; username: string }>();

io.on('connection', (socket) => {
  // 用戶登錄
  socket.on('login', (username: string) => {
    users.set(socket.id, { socketId: socket.id, username });
    socket.emit('loginSuccess', { userId: socket.id });
  });

  // 獲取房間列表
  socket.on('getRooms', () => {
    const roomList = Array.from(rooms.values()).map((room) => ({
      id: room.id,
      name: room.name,
      userCount: room.users.size,
    }));
    socket.emit('roomList', roomList);
  });

  // 加入房間
  socket.on('joinRoom', (roomId: string) => {
    const room = rooms.get(roomId);
    if (room) {
      socket.join(roomId);
      room.users.add(socket.id);
      
      const user = users.get(socket.id);
      io.to(roomId).emit('userJoined', {
        userId: socket.id,
        username: user?.username,
      });
    }
  });

  // 發送消息
  socket.on('sendMessage', ({ roomId, content }) => {
    const user = users.get(socket.id);
    const message: Message = {
      id: Date.now().toString(),
      userId: socket.id,
      username: user?.username || '匿名',
      content,
      timestamp: Date.now(),
    };
    
    io.to(roomId).emit('newMessage', message);
  });

  // 斷開連接
  socket.on('disconnect', () => {
    users.delete(socket.id);
    rooms.forEach((room) => {
      if (room.users.has(socket.id)) {
        room.users.delete(socket.id);
        io.to(room.id).emit('userLeft', { userId: socket.id });
      }
    });
  });
});
```

#### 客戶端

```tsx
'use client';

import { useEffect, useState, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

interface Message {
  id: string;
  userId: string;
  username: string;
  content: string;
  timestamp: number;
}

export default function ChatRoom({ roomId }: { roomId: string }) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [users, setUsers] = useState<string[]>([]);

  useEffect(() => {
    const newSocket = io('http://localhost:3001');
    setSocket(newSocket);

    newSocket.emit('joinRoom', roomId);

    newSocket.on('newMessage', (message: Message) => {
      setMessages((prev) => [...prev, message]);
    });

    newSocket.on('userJoined', ({ username }) => {
      setUsers((prev) => [...prev, username]);
    });

    newSocket.on('userLeft', ({ username }) => {
      setUsers((prev) => prev.filter((u) => u !== username));
    });

    return () => {
      newSocket.emit('leaveRoom', roomId);
      newSocket.close();
    };
  }, [roomId]);

  const sendMessage = useCallback(() => {
    if (socket && input.trim()) {
      socket.emit('sendMessage', { roomId, content: input });
      setInput('');
    }
  }, [socket, input, roomId]);

  return (
    <div className="flex h-screen">
      {/* 用戶列表 */}
      <aside className="w-48 bg-gray-100 p-4">
        <h3 className="font-bold mb-2">在線用戶</h3>
        {users.map((user) => (
          <div key={user}>{user}</div>
        ))}
      </aside>

      {/* 聊天區域 */}
      <main className="flex-1 flex flex-col">
        <div className="flex-1 overflow-auto p-4">
          {messages.map((msg) => (
            <div key={msg.id} className="mb-2">
              <span className="font-bold">{msg.username}: </span>
              <span>{msg.content}</span>
            </div>
          ))}
        </div>

        <div className="p-4 border-t flex gap-2">
          <input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
            className="flex-1 p-2 border rounded"
            placeholder="輸入消息..."
          />
          <button onClick={sendMessage} className="px-4 py-2 bg-blue-500 text-white rounded">
            發送
          </button>
        </div>
      </main>
    </div>
  );
}
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你實現完整的聊天功能。
- **需求定義公式**：`"請幫我實現一個支持多房間的聊天應用，包括用戶加入/離開通知、消息歷史和在線用戶列表。"`
- **關鍵術語**：`room`、`join`、`leave`、`broadcast`、`消息廣播`

### 避坑指南

- **消息順序**：網絡延遲可能導致消息亂序，考慮使用時間戳排序。
- **消息去重**：重連時可能收到重複消息，需要客戶端去重。
- **用戶狀態同步**：斷線重連後需要重新同步房間狀態。
