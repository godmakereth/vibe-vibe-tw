---
title: "12.7.1 API 版本的規則——API 版本策略：URL/Header 版本控制"
typora-root-url: ../../public
---

# 12.7.1 API 版本的規則——API 版本策略：URL/Header 版本控制

### 一句話破題

API 版本控制有三種主流方式：URL 路徑、Query 參數、請求頭——選擇哪種取決於你的場景和團隊偏好。

### 版本控制方式對比

| 方式 | 示例 | 優點 | 缺點 |
|------|------|------|------|
| URL 路徑 | `/api/v1/users` | 直觀、易緩存 | URL 變化大 |
| Query 參數 | `/api/users?version=1` | 靈活 | 容易被忽略 |
| 請求頭 | `Accept: application/vnd.api+json;version=1` | URL 乾淨 | 不直觀 |

### URL 路徑版本控制

最常見的方式，推薦用於大多數場景：

```typescript
// app/api/v1/users/route.ts
export async function GET() {
  return Response.json({ version: 'v1', users: [] });
}

// app/api/v2/users/route.ts
export async function GET() {
  return Response.json({ 
    version: 'v2', 
    data: { users: [] },  // v2 改變了響應結構
    meta: { total: 0 },
  });
}
```

### 請求頭版本控制

適合不想改變 URL 的場景：

```typescript
// app/api/users/route.ts
export async function GET(req: Request) {
  const version = req.headers.get('X-API-Version') || '1';
  
  switch (version) {
    case '1':
      return Response.json({ users: [] });
    case '2':
      return Response.json({ data: { users: [] }, meta: {} });
    default:
      return Response.json({ error: '不支持的版本' }, { status: 400 });
  }
}
```

### 語義化版本

遵循 SemVer 規範：

```
主版本.次版本.修訂號
  ^      ^      ^
  |      |      +--- 向後兼容的問題修復
  |      +---------- 向後兼容的新功能
  +----------------- 破壞性變更
```

```typescript
// 版本比較工具
interface Version {
  major: number;
  minor: number;
  patch: number;
}

function parseVersion(version: string): Version {
  const [major, minor, patch] = version.split('.').map(Number);
  return { major, minor, patch };
}

function isCompatible(required: string, current: string): boolean {
  const req = parseVersion(required);
  const cur = parseVersion(current);
  
  // 主版本必須匹配
  if (req.major !== cur.major) return false;
  
  // 當前版本必須 >= 要求版本
  if (cur.minor < req.minor) return false;
  if (cur.minor === req.minor && cur.patch < req.patch) return false;
  
  return true;
}
```

### Next.js 中的多版本 API

```typescript
// lib/api-versions.ts
type Handler = (req: Request) => Promise<Response>;

const handlers: Record<string, Record<string, Handler>> = {
  'v1': {
    'GET /users': async () => Response.json({ users: [] }),
  },
  'v2': {
    'GET /users': async () => Response.json({ data: { users: [] } }),
  },
};

export function createVersionedHandler(path: string) {
  return async (req: Request) => {
    const version = req.headers.get('X-API-Version') || 'v2'; // 默認最新版本
    const method = req.method;
    const key = `${method} ${path}`;
    
    const handler = handlers[version]?.[key];
    if (!handler) {
      return Response.json({ error: '端點不存在' }, { status: 404 });
    }
    
    return handler(req);
  };
}
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你設計 API 版本策略。
- **需求定義公式**：`"請幫我設計一個 Next.js API 的版本控制方案，支持 URL 路徑版本和請求頭版本兩種方式。"`
- **關鍵術語**：`API 版本控制`、`SemVer`、`向後兼容`、`破壞性變更`

### 避坑指南

- **從 v1 開始**：不要用 v0，它暗示不穩定。
- **文檔要跟上**：每個版本都需要獨立的文檔。
- **設置默認版本**：未指定版本時使用穩定版本（不一定是最新版）。
