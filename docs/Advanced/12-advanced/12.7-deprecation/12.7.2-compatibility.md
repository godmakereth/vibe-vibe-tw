---
title: "12.7.2 別讓升級搞壞舊應用——向後兼容：破壞性變更的避免"
typora-root-url: ../../public
---

# 12.7.2 別讓升級搞壞舊應用——向後兼容：破壞性變更的避免

### 一句話破題

向後兼容意味着"新版本不破壞舊代碼"——這需要在設計階段就考慮未來的演進。

### 什麼是破壞性變更

| 變更類型 | 示例 | 是否破壞性 |
|----------|------|------------|
| 添加可選字段 | 響應中新增 `meta` 字段 | 否 |
| 添加必填字段 | 請求必須包含 `userId` | 是 |
| 刪除字段 | 移除 `legacyId` 字段 | 是 |
| 重命名字段 | `user_name` → `userName` | 是 |
| 改變類型 | `id: number` → `id: string` | 是 |
| 改變行爲 | 排序順序變化 | 可能 |

### 添加字段而非刪除

```typescript
// 舊版本響應
interface UserV1 {
  id: number;
  name: string;
}

// 新版本響應（向後兼容）
interface UserV2 {
  id: number;
  name: string;
  email?: string;      // 新增可選字段
  displayName?: string; // 新增可選字段
}

// 客戶端代碼仍然有效
function displayUser(user: UserV1) {
  console.log(user.name); // 仍然有效
}
```

### 使用適配器模式

當必須改變結構時，提供適配層：

```typescript
// 內部使用新結構
interface UserInternal {
  id: string; // 改爲 string
  profile: {
    displayName: string;
    email: string;
  };
}

// 對外提供適配的舊結構
function toV1Response(user: UserInternal): UserV1 {
  return {
    id: parseInt(user.id), // 轉回 number
    name: user.profile.displayName,
  };
}

function toV2Response(user: UserInternal): UserV2 {
  return {
    id: user.id, // 使用新的 string 類型
    displayName: user.profile.displayName,
    email: user.profile.email,
  };
}
```

### 功能開關

使用功能開關逐步遷移：

```typescript
interface FeatureFlags {
  useNewUserFormat: boolean;
  enableEmailField: boolean;
}

async function getUser(id: string, flags: FeatureFlags) {
  const user = await db.user.findUnique({ where: { id } });
  
  if (flags.useNewUserFormat) {
    return {
      id: user.id,
      profile: {
        displayName: user.name,
        email: flags.enableEmailField ? user.email : undefined,
      },
    };
  }
  
  // 返回舊格式
  return {
    id: parseInt(user.id),
    name: user.name,
  };
}
```

### 兼容性測試

```typescript
import { describe, it, expect } from 'vitest';

describe('API 兼容性測試', () => {
  it('v2 響應應該兼容 v1 客戶端', async () => {
    const v2Response = await fetch('/api/v2/users/1');
    const data = await v2Response.json();
    
    // v1 客戶端期望的字段必須存在
    expect(data).toHaveProperty('id');
    expect(data).toHaveProperty('name');
    expect(typeof data.id).toBe('number'); // v1 期望 number
  });
  
  it('新增字段不應破壞舊客戶端', async () => {
    const response = await fetch('/api/v2/users/1');
    const data = await response.json();
    
    // 舊客戶端忽略新字段，不應報錯
    const oldClientCode = () => {
      console.log(data.name);
    };
    
    expect(oldClientCode).not.toThrow();
  });
});
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你評估變更是否破壞兼容性。
- **需求定義公式**：`"請分析這個 API 變更是否是破壞性的，如果是，請建議如何保持向後兼容。"`
- **關鍵術語**：`向後兼容 (backward compatibility)`、`破壞性變更 (breaking change)`、`適配器模式`

### 避坑指南

- **添加而非刪除**：永遠不要刪除字段，只添加新字段。
- **可選而非必填**：新字段儘量設爲可選。
- **文檔標註**：明確標註哪些字段可能在未來版本變化。
