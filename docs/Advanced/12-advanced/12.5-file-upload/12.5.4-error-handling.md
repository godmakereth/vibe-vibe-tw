---
title: "12.5.4 上傳失敗怎麼辦——錯誤處理：網絡異常與重試機制"
typora-root-url: ../../public
---

# 12.5.4 上傳失敗怎麼辦——錯誤處理：網絡異常與重試機制

### 一句話破題

網絡不可靠，上傳必然會失敗——關鍵是用指數退避重試和用戶友好的反饋讓失敗變得"可接受"。

### 重試策略

```typescript
interface RetryConfig {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
}

async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig = { maxRetries: 3, baseDelay: 1000, maxDelay: 10000 }
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (attempt === config.maxRetries) {
        break;
      }

      // 指數退避 + 隨機抖動
      const delay = Math.min(
        config.baseDelay * Math.pow(2, attempt) + Math.random() * 1000,
        config.maxDelay
      );

      console.log(`重試 ${attempt + 1}/${config.maxRetries}，等待 ${delay}ms`);
      await new Promise((r) => setTimeout(r, delay));
    }
  }

  throw lastError;
}

// 使用示例
await withRetry(() => uploadChunk(chunk, fileId), {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 10000,
});
```

### 錯誤分類處理

```typescript
enum UploadErrorType {
  NETWORK = 'network',
  TIMEOUT = 'timeout',
  SERVER = 'server',
  VALIDATION = 'validation',
  QUOTA = 'quota',
}

function classifyError(error: unknown): UploadErrorType {
  if (error instanceof TypeError && error.message.includes('fetch')) {
    return UploadErrorType.NETWORK;
  }
  if (error instanceof DOMException && error.name === 'AbortError') {
    return UploadErrorType.TIMEOUT;
  }
  if (error instanceof Response) {
    if (error.status === 413) return UploadErrorType.QUOTA;
    if (error.status >= 400 && error.status < 500) return UploadErrorType.VALIDATION;
    if (error.status >= 500) return UploadErrorType.SERVER;
  }
  return UploadErrorType.SERVER;
}

async function handleUploadError(error: unknown, chunk: Chunk): Promise<'retry' | 'skip' | 'abort'> {
  const errorType = classifyError(error);

  switch (errorType) {
    case UploadErrorType.NETWORK:
    case UploadErrorType.TIMEOUT:
    case UploadErrorType.SERVER:
      return 'retry'; // 可重試的錯誤

    case UploadErrorType.VALIDATION:
      console.error(`分片 ${chunk.index} 驗證失敗，跳過`);
      return 'skip';

    case UploadErrorType.QUOTA:
      console.error('存儲配額已滿');
      return 'abort';

    default:
      return 'abort';
  }
}
```

### 完整上傳器實現

```typescript
interface UploadProgress {
  uploaded: number;
  total: number;
  percent: number;
  speed: number; // bytes/s
  remaining: number; // seconds
}

class RobustUploader {
  private abortController: AbortController | null = null;
  private startTime = 0;
  private uploadedBytes = 0;

  async upload(
    file: File,
    onProgress: (progress: UploadProgress) => void,
    onError: (error: Error, canRetry: boolean) => void
  ) {
    this.abortController = new AbortController();
    this.startTime = Date.now();
    this.uploadedBytes = 0;

    const chunks = createChunks(file);
    const failedChunks: Chunk[] = [];

    for (const chunk of chunks) {
      if (this.abortController.signal.aborted) {
        throw new Error('上傳已取消');
      }

      try {
        await withRetry(() => this.uploadChunk(chunk), { maxRetries: 3 });
        this.uploadedBytes += chunk.blob.size;
        onProgress(this.calculateProgress(file.size));
      } catch (error) {
        const action = await handleUploadError(error, chunk);

        if (action === 'abort') {
          onError(error as Error, false);
          throw error;
        } else if (action === 'retry') {
          failedChunks.push(chunk);
        }
      }
    }

    // 重試失敗的分片
    if (failedChunks.length > 0) {
      onError(new Error(`${failedChunks.length} 個分片上傳失敗，嘗試重新上傳`), true);

      for (const chunk of failedChunks) {
        await withRetry(() => this.uploadChunk(chunk), { maxRetries: 5 });
      }
    }
  }

  cancel() {
    this.abortController?.abort();
  }

  private calculateProgress(totalSize: number): UploadProgress {
    const elapsed = (Date.now() - this.startTime) / 1000;
    const speed = this.uploadedBytes / elapsed;
    const remaining = (totalSize - this.uploadedBytes) / speed;

    return {
      uploaded: this.uploadedBytes,
      total: totalSize,
      percent: (this.uploadedBytes / totalSize) * 100,
      speed,
      remaining,
    };
  }
}
```

### 用戶友好的錯誤提示

```tsx
function UploadError({ error, onRetry, onCancel }: {
  error: Error;
  onRetry: () => void;
  onCancel: () => void;
}) {
  const errorMessages: Record<UploadErrorType, string> = {
    network: '網絡連接失敗，請檢查網絡後重試',
    timeout: '上傳超時，請稍後重試',
    server: '服務器繁忙，請稍後重試',
    validation: '文件格式不正確',
    quota: '存儲空間不足',
  };

  return (
    <div className="p-4 bg-red-50 border border-red-200 rounded">
      <p className="text-red-700">{errorMessages[classifyError(error)]}</p>
      <div className="mt-2 flex gap-2">
        <button onClick={onRetry} className="px-3 py-1 bg-red-600 text-white rounded">
          重試
        </button>
        <button onClick={onCancel} className="px-3 py-1 border rounded">
          取消
        </button>
      </div>
    </div>
  );
}
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你實現健壯的上傳錯誤處理。
- **需求定義公式**：`"請幫我實現一個帶有指數退避重試、錯誤分類和用戶友好提示的文件上傳組件。"`
- **關鍵術語**：`指數退避 (exponential backoff)`、`重試 (retry)`、`AbortController`

### 避坑指南

- **不要無限重試**：設置最大重試次數，避免永遠卡住。
- **區分錯誤類型**：服務端錯誤可以重試，驗證錯誤不應重試。
- **提供取消選項**：讓用戶能夠取消正在進行的上傳。
