---
title: "12.5.3 傳的數據對不對——完整性校驗：MD5/SHA256 哈希驗證"
typora-root-url: ../../public
---

# 12.5.3 傳的數據對不對——完整性校驗：MD5/SHA256 哈希驗證

### 一句話破題

完整性校驗確保上傳的文件沒有在傳輸過程中損壞——客戶端計算 hash，服務端驗證 hash，不一致就重傳。

### 校驗層級

| 層級 | 校驗對象 | 目的 |
|------|----------|------|
| 分片級 | 單個分片 | 快速定位損壞分片 |
| 文件級 | 整個文件 | 確保最終文件完整 |

### 分片級校驗

```typescript
async function calculateChunkHash(chunk: Blob): Promise<string> {
  const buffer = await chunk.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

async function uploadChunkWithVerification(chunk: Chunk, fileId: string) {
  const hash = await calculateChunkHash(chunk.blob);

  const formData = new FormData();
  formData.append('chunk', chunk.blob);
  formData.append('index', chunk.index.toString());
  formData.append('fileId', fileId);
  formData.append('hash', hash);

  const response = await fetch('/api/upload/chunk', {
    method: 'POST',
    body: formData,
  });

  const result = await response.json();
  if (!result.verified) {
    throw new Error(`分片 ${chunk.index} 校驗失敗`);
  }
}
```

### 服務端驗證

```typescript
// app/api/upload/chunk/route.ts
import { createHash } from 'crypto';

export async function POST(req: Request) {
  const formData = await req.formData();
  const chunk = formData.get('chunk') as File;
  const clientHash = formData.get('hash') as string;
  const index = formData.get('index') as string;
  const fileId = formData.get('fileId') as string;

  const buffer = Buffer.from(await chunk.arrayBuffer());

  // 計算服務端 hash
  const serverHash = createHash('sha256').update(buffer).digest('hex');

  if (serverHash !== clientHash) {
    return Response.json({ verified: false, error: 'Hash mismatch' }, { status: 400 });
  }

  // 保存分片
  const chunkDir = join(process.cwd(), 'uploads', fileId);
  await mkdir(chunkDir, { recursive: true });
  await writeFile(join(chunkDir, index), buffer);

  return Response.json({ verified: true });
}
```

### 文件級校驗

合併後驗證整個文件：

```typescript
// 客戶端：計算整個文件的 hash
async function calculateFileHash(file: File): Promise<string> {
  const chunkSize = 10 * 1024 * 1024; // 10MB 分塊處理避免內存問題
  let offset = 0;
  const hashParts: ArrayBuffer[] = [];

  while (offset < file.size) {
    const chunk = file.slice(offset, offset + chunkSize);
    hashParts.push(await chunk.arrayBuffer());
    offset += chunkSize;
  }

  // 使用 Web Crypto API
  const combined = await new Blob(hashParts.map((p) => new Uint8Array(p))).arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', combined);
  return Array.from(new Uint8Array(hashBuffer))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

// 上傳完成後驗證
async function verifyUpload(fileId: string, expectedHash: string) {
  const response = await fetch(`/api/upload/verify?fileId=${fileId}&hash=${expectedHash}`);
  const { verified } = await response.json();
  return verified;
}
```

### 使用流式計算避免內存問題

```typescript
// 使用 Web Streams API 流式計算 hash
async function calculateHashStreaming(file: File): Promise<string> {
  const reader = file.stream().getReader();
  const chunks: Uint8Array[] = [];

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }

  const combined = new Uint8Array(chunks.reduce((acc, c) => acc + c.length, 0));
  let offset = 0;
  chunks.forEach((c) => {
    combined.set(c, offset);
    offset += c.length;
  });

  const hashBuffer = await crypto.subtle.digest('SHA-256', combined);
  return Array.from(new Uint8Array(hashBuffer))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你實現文件完整性校驗。
- **需求定義公式**：`"請幫我實現分片上傳的完整性校驗，包括分片級 SHA-256 校驗和最終文件校驗。"`
- **關鍵術語**：`SHA-256`、`MD5`、`hash`、`完整性校驗 (integrity check)`

### 避坑指南

- **性能考慮**：大文件 hash 計算很耗時，可以使用 Web Worker 避免阻塞 UI。
- **MD5 vs SHA-256**：MD5 更快但有碰撞風險，重要數據用 SHA-256。
- **內存管理**：不要一次性加載整個文件到內存，使用流式處理。
