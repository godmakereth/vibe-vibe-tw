---
title: "12.3.3 即時生成內容——流式文本生成：useChat/useCompletion 實戰"
typora-root-url: ../../public
---

# 12.3.3 即時生成內容——流式文本生成：useChat/useCompletion 實戰

### 一句話破題

`useChat` 用於多輪對話，`useCompletion` 用於單次生成——選對 Hook，事半功倍。

### useChat vs useCompletion

| 特性 | useChat | useCompletion |
|------|---------|---------------|
| 用途 | 多輪對話 | 單次文本生成 |
| 消息歷史 | 自動維護 | 不維護 |
| 典型場景 | 聊天機器人 | 文章生成、代碼補全 |
| API 端點 | `/api/chat` | `/api/completion` |

### useChat 深度使用

```tsx
'use client';

import { useChat, Message } from 'ai/react';

export default function ChatBot() {
  const {
    messages,      // 消息歷史
    input,         // 輸入框內容
    handleInputChange,
    handleSubmit,
    isLoading,     // 是否正在生成
    error,         // 錯誤信息
    reload,        // 重新生成最後一條消息
    stop,          // 停止生成
    setMessages,   // 手動設置消息
    append,        // 追加消息
  } = useChat({
    api: '/api/chat',
    initialMessages: [
      { id: '1', role: 'system', content: '你是一個友好的助手' },
    ],
    onFinish: (message) => {
      console.log('生成完成:', message);
    },
    onError: (error) => {
      console.error('發生錯誤:', error);
    },
  });

  return (
    <div className="flex flex-col h-screen">
      {/* 消息列表 */}
      <div className="flex-1 overflow-auto p-4">
        {messages.filter(m => m.role !== 'system').map((m) => (
          <div
            key={m.id}
            className={`mb-4 ${m.role === 'user' ? 'text-right' : 'text-left'}`}
          >
            <span className={`inline-block p-3 rounded-lg ${
              m.role === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-200'
            }`}>
              {m.content}
            </span>
          </div>
        ))}
        
        {isLoading && (
          <div className="text-gray-500">AI 正在思考...</div>
        )}
      </div>

      {/* 輸入區域 */}
      <form onSubmit={handleSubmit} className="p-4 border-t">
        <div className="flex gap-2">
          <input
            value={input}
            onChange={handleInputChange}
            placeholder="輸入消息..."
            className="flex-1 p-2 border rounded"
            disabled={isLoading}
          />
          {isLoading ? (
            <button type="button" onClick={stop} className="px-4 py-2 bg-red-500 text-white rounded">
              停止
            </button>
          ) : (
            <button type="submit" className="px-4 py-2 bg-blue-500 text-white rounded">
              發送
            </button>
          )}
        </div>
      </form>

      {error && (
        <div className="p-4 bg-red-100 text-red-700">
          出錯了: {error.message}
          <button onClick={() => reload()} className="ml-2 underline">
            重試
          </button>
        </div>
      )}
    </div>
  );
}
```

### useCompletion 實戰

```tsx
'use client';

import { useCompletion } from 'ai/react';

export default function ArticleGenerator() {
  const {
    completion,    // 生成的文本
    input,
    handleInputChange,
    handleSubmit,
    isLoading,
    error,
  } = useCompletion({
    api: '/api/completion',
  });

  return (
    <div className="p-4">
      <form onSubmit={handleSubmit}>
        <textarea
          value={input}
          onChange={handleInputChange}
          placeholder="輸入文章主題..."
          className="w-full p-2 border rounded"
          rows={3}
        />
        <button
          type="submit"
          disabled={isLoading}
          className="mt-2 px-4 py-2 bg-blue-500 text-white rounded"
        >
          {isLoading ? '生成中...' : '生成文章'}
        </button>
      </form>

      {completion && (
        <div className="mt-4 p-4 bg-gray-100 rounded whitespace-pre-wrap">
          {completion}
        </div>
      )}
    </div>
  );
}
```

對應的 API 路由：

```typescript
// app/api/completion/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText } from 'ai';

export async function POST(req: Request) {
  const { prompt } = await req.json();

  const result = streamText({
    model: openai('gpt-4o'),
    prompt: `請根據以下主題生成一篇文章:\n\n${prompt}`,
  });

  return result.toDataStreamResponse();
}
```

### 高級：自定義消息渲染

```tsx
import { useChat } from 'ai/react';
import ReactMarkdown from 'react-markdown';

export default function MarkdownChat() {
  const { messages, ... } = useChat();

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          {m.role === 'assistant' ? (
            <ReactMarkdown>{m.content}</ReactMarkdown>
          ) : (
            <p>{m.content}</p>
          )}
        </div>
      ))}
    </div>
  );
}
```

### AI 協作指南

- **核心意圖**：讓 AI 幫你實現特定的對話功能或生成功能。
- **需求定義公式**：`"請幫我用 useChat 實現一個支持 Markdown 渲染、帶有停止生成按鈕的聊天界面。"`
- **關鍵術語**：`useChat`、`useCompletion`、`messages`、`isLoading`、`stop`

### 避坑指南

- **系統消息不要在 UI 中顯示**：過濾掉 `role === 'system'` 的消息。
- **處理空消息**：用戶可能會發送空消息，需要在表單層面驗證。
- **注意消息 ID**：每條消息需要唯一 ID，SDK 會自動生成，但手動添加消息時需注意。
