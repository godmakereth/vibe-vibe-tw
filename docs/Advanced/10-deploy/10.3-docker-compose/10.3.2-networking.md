---
title: "10.3.2 服務之間如何對話——網絡與卷：服務間通信與數據共享"
typora-root-url: ../../public
---

# 10.3.2 服務之間如何對話——網絡與卷：服務間通信與數據共享

容器間通信，用服務名就行。

## Docker Compose 網絡原理

Docker Compose 會自動爲項目創建一個專屬網絡，所有服務都加入這個網絡。在這個網絡中，服務可以通過**服務名**相互訪問。

```mermaid
flowchart TB
    subgraph app_network
        A[frontend] -->|api:3001| B[api]
        B -->|postgres:5432| C[postgres]
        B -->|redis:6379| D[redis]
    end
    E[外部訪問] -->|localhost:3000| A
```

## 服務間通信

### 使用服務名作爲主機名

```yaml
services:
  api:
    environment:
      # 使用服務名 postgres 而非 localhost
      - DATABASE_URL=postgresql://user:pass@postgres:5432/mydb
      # 使用服務名 redis
      - REDIS_URL=redis://redis:6379
```

::: warning 常見錯誤
在容器內使用 `localhost` 是訪問容器自己，而非其他服務。必須使用服務名！
:::

### 端口規則

| 場景 | 配置 | 說明 |
|------|------|------|
| 容器間通信 | 直接使用容器端口 | `postgres:5432` |
| 外部訪問 | 需要端口映射 | `ports: "5432:5432"` |
| 僅內部訪問 | 使用 expose | `expose: ["5432"]` |

```yaml
services:
  postgres:
    image: postgres:15
    # 不映射端口，外部無法直接訪問，更安全
    expose:
      - "5432"
```

## 自定義網絡

### 多網絡隔離

```yaml
services:
  frontend:
    networks:
      - frontend-network
  
  api:
    networks:
      - frontend-network
      - backend-network
  
  postgres:
    networks:
      - backend-network  # 數據庫不暴露給前端

networks:
  frontend-network:
  backend-network:
```

```mermaid
flowchart LR
    subgraph frontend-network
        A[frontend] --> B[api]
    end
    subgraph backend-network
        B --> C[postgres]
    end
```

### 網絡別名

```yaml
services:
  postgres:
    networks:
      default:
        aliases:
          - db
          - database
```

現在可以用 `postgres`、`db`、`database` 三個名稱訪問同一服務。

## 數據卷詳解

### 卷的類型

| 類型 | 語法 | 特點 |
|------|------|------|
| 命名卷 | `volume-name:/path` | Docker 管理，持久化 |
| 綁定掛載 | `./host/path:/container/path` | 直接映射主機目錄 |
| 匿名卷 | `/path` | 臨時，容器刪除即丟失 |

### 命名卷（推薦用於數據持久化）

```yaml
services:
  postgres:
    volumes:
      - postgres-data:/var/lib/postgresql/data

volumes:
  postgres-data:  # 聲明命名卷
    driver: local
```

### 綁定掛載（開發時常用）

```yaml
services:
  api:
    volumes:
      # 將本地代碼掛載到容器，實現熱重載
      - ./api:/app
      # 排除 node_modules（使用匿名卷）
      - /app/node_modules
```

### 只讀掛載

```yaml
services:
  nginx:
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
```

## 數據共享場景

### 場景一：多服務共享數據

```yaml
services:
  api:
    volumes:
      - shared-uploads:/app/uploads

  worker:
    volumes:
      - shared-uploads:/app/uploads

volumes:
  shared-uploads:
```

### 場景二：初始化腳本

```yaml
services:
  postgres:
    volumes:
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
```

PostgreSQL 會在首次啓動時自動執行 `/docker-entrypoint-initdb.d/` 下的腳本。

## 查看網絡和卷

```bash
# 查看項目網絡
docker network ls | grep myproject

# 查看網絡詳情
docker network inspect myproject_default

# 查看卷
docker volume ls

# 查看卷詳情
docker volume inspect myproject_postgres-data
```

## 清理資源

```bash
# 停止並刪除容器，但保留卷
docker compose down

# 停止並刪除容器和卷（危險！數據會丟失）
docker compose down -v

# 刪除未使用的卷
docker volume prune
```

::: danger 數據安全
`docker compose down -v` 會刪除所有數據卷，生產環境慎用！
:::

## 最佳實踐

1. **生產環境不映射數據庫端口**：避免外部直接訪問
2. **使用命名卷持久化數據**：比綁定掛載更可靠
3. **敏感服務使用獨立網絡**：隔離前後端
4. **定期備份數據卷**：使用 `docker run` 掛載卷並執行備份
