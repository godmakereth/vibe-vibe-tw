---
title: "10.5.1 網站還活着嗎——應用監控：健康檢查端點與指標收集"
typora-root-url: ../../public
---

# 10.5.1 網站還活着嗎——應用監控：健康檢查端點與指標收集

每 5 分鐘問一次"你還好嗎"，比用戶告訴你"掛了"好得多。

## 健康檢查原理

```mermaid
flowchart LR
    A[監控服務] -->|定時請求| B[/health]
    B -->|200 OK| C[正常]
    B -->|非200/超時| D[告警]
```

## 健康檢查端點設計

### 基礎版本

```typescript
// NestJS health.controller.ts
@Controller('health')
export class HealthController {
  @Get()
  check() {
    return { status: 'ok' };
  }
}
```

### 完整版本

```typescript
@Controller('health')
export class HealthController {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  @Get()
  async check() {
    const checks = {
      status: 'ok',
      timestamp: new Date().toISOString(),
      services: {},
    };

    // 檢查數據庫
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      checks.services['database'] = 'ok';
    } catch {
      checks.services['database'] = 'error';
      checks.status = 'degraded';
    }

    // 檢查 Redis
    try {
      await this.redis.ping();
      checks.services['redis'] = 'ok';
    } catch {
      checks.services['redis'] = 'error';
      checks.status = 'degraded';
    }

    return checks;
  }

  @Get('live')
  liveness() {
    return { status: 'ok' };
  }

  @Get('ready')
  async readiness() {
    // 檢查所有依賴是否就緒
    await this.prisma.$queryRaw`SELECT 1`;
    return { status: 'ok' };
  }
}
```

## 健康檢查類型

| 類型 | 端點 | 用途 |
|------|------|------|
| Liveness | `/health/live` | 進程是否存活 |
| Readiness | `/health/ready` | 是否可以接收流量 |
| Startup | `/health/startup` | 啓動是否完成 |

## 外部監控服務

### UptimeRobot（推薦）

免費版支持 50 個監控：

1. 註冊 [UptimeRobot](https://uptimerobot.com/)
2. 添加新監控
3. 配置：
   - 監控類型：HTTP(s)
   - URL：`https://api.example.com/health`
   - 間隔：5 分鐘
   - 告警聯繫人：郵箱/Webhook

### Better Stack（日誌+監控）

```javascript
// 集成 Better Stack SDK
import { Logtail } from '@logtail/node';
const logtail = new Logtail('your-source-token');

logtail.info('Application started');
```

## 1Panel 服務器監控

1Panel 內置服務器監控：

| 指標 | 說明 |
|------|------|
| CPU 使用率 | 整體/各核心 |
| 內存使用 | 已用/可用/緩存 |
| 磁盤使用 | 各分區使用率 |
| 網絡流量 | 入站/出站 |

路徑：面板首頁 → 監控

## Docker 容器監控

### docker stats

```bash
# 即時查看容器資源使用
docker stats

# 輸出示例
CONTAINER ID   NAME     CPU %   MEM USAGE / LIMIT   NET I/O        BLOCK I/O
abc123def456   api      0.50%   256MiB / 1GiB       1.2MB / 500KB  0B / 0B
```

### 監控容器健康

```yaml
# docker-compose.yml
services:
  api:
    image: my-api
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

## 關鍵指標

### 服務器指標

| 指標 | 警戒值 | 說明 |
|------|--------|------|
| CPU 使用率 | > 80% | 考慮擴容 |
| 內存使用率 | > 85% | 可能 OOM |
| 磁盤使用率 | > 90% | 清理日誌 |
| 網絡帶寬 | > 80% | 升級帶寬 |

### 應用指標

| 指標 | 警戒值 | 說明 |
|------|--------|------|
| 響應時間 | > 2s | 性能問題 |
| 錯誤率 | > 1% | 代碼問題 |
| QPS | 接近上限 | 考慮擴容 |

## 自定義指標收集

### 簡單計數器

```typescript
// 統計 API 調用次數
const apiMetrics = {
  totalRequests: 0,
  errorRequests: 0,
  
  record(success: boolean) {
    this.totalRequests++;
    if (!success) this.errorRequests++;
  },
  
  getStats() {
    return {
      total: this.totalRequests,
      errors: this.errorRequests,
      errorRate: this.errorRequests / this.totalRequests,
    };
  }
};

@Get('metrics')
getMetrics() {
  return apiMetrics.getStats();
}
```

## 監控最佳實踐

1. **多層次監控**：服務器 + 應用 + 業務
2. **合理間隔**：外部監控 5 分鐘，內部可更頻繁
3. **避免誤報**：設置重試次數，連續失敗才告警
4. **監控監控**：確保監控服務本身可用
5. **文檔記錄**：記錄各指標的含義和閾值

## 常見問題

| 問題 | 原因 | 解決方案 |
|------|------|----------|
| 誤報太多 | 閾值設置不合理 | 調整閾值，增加重試 |
| 監控延遲 | 檢查間隔太長 | 縮短間隔（但注意成本） |
| 無法訪問 | 網絡/防火牆問題 | 檢查安全組規則 |
