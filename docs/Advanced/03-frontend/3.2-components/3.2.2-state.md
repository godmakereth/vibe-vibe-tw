---
title: "3.2.2 積木的狀態誰來管——State 管理：useState/useReducer 選擇"
typora-root-url: ../../public
---

# 3.2.2 積木的狀態誰來管——State 管理

### 一句話破題

State 是組件的"記憶"，讓 UI 能夠響應用戶交互和數據變化而更新。

### 核心價值

Props 是外部傳入的只讀數據，而 State 是組件內部可以自主管理和修改的數據。當 State 變化時，React 會自動重新渲染組件。

### useState 基礎

```tsx
'use client'  // 使用 Hooks 必須是 Client Component

import { useState } from 'react'

function Counter() {
  // 聲明狀態：[當前值, 更新函數] = useState(初始值)
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>當前計數：{count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount(prev => prev - 1)}>-1</button>
    </div>
  )
}
```

### 更新狀態的兩種方式

```tsx
// 方式一：直接設置新值
setCount(5)

// 方式二：基於前一個狀態更新（推薦，避免閉包陷阱）
setCount(prev => prev + 1)
```

**什麼時候用函數式更新？**

當新狀態依賴於舊狀態時，務必使用函數式更新：

```tsx
// 錯誤：可能因閉包導致意外行爲
const handleClick = () => {
  setCount(count + 1)
  setCount(count + 1)  // 可能不會 +2
}

// 正確：保證基於最新狀態
const handleClick = () => {
  setCount(prev => prev + 1)
  setCount(prev => prev + 1)  // 一定會 +2
}
```

### 對象和數組狀態

**對象狀態：**

```tsx
const [user, setUser] = useState({ name: '', age: 0 })

// 更新對象的某個字段（必須創建新對象）
setUser(prev => ({ ...prev, name: '張三' }))
```

**數組狀態：**

```tsx
const [items, setItems] = useState<string[]>([])

// 添加
setItems(prev => [...prev, 'new item'])

// 刪除
setItems(prev => prev.filter((_, i) => i !== index))

// 更新
setItems(prev => prev.map((item, i) => i === index ? 'updated' : item))
```

### useReducer：複雜狀態的救星

當狀態邏輯變得複雜時，`useReducer` 比多個 `useState` 更清晰：

```tsx
'use client'

import { useReducer } from 'react'

// 定義狀態類型
interface State {
  count: number
  loading: boolean
  error: string | null
}

// 定義 Action 類型
type Action = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'setLoading'; payload: boolean }
  | { type: 'setError'; payload: string }

// Reducer 函數
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + 1 }
    case 'decrement':
      return { ...state, count: state.count - 1 }
    case 'setLoading':
      return { ...state, loading: action.payload }
    case 'setError':
      return { ...state, error: action.payload }
    default:
      return state
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, {
    count: 0,
    loading: false,
    error: null
  })
  
  return (
    <div>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+1</button>
    </div>
  )
}
```

### useState vs useReducer

| 場景 | 推薦 |
|------|------|
| 單一值（數字、字符串、布爾） | useState |
| 簡單對象（2-3 個字段） | useState |
| 複雜對象（多字段、多種更新方式） | useReducer |
| 狀態更新有明確的"動作"語義 | useReducer |
| 需要集中管理狀態邏輯 | useReducer |

### 狀態提升

當多個組件需要共享狀態時，將狀態提升到它們的共同父組件：

```tsx
// 父組件持有狀態
function Parent() {
  const [value, setValue] = useState('')
  
  return (
    <div>
      <Input value={value} onChange={setValue} />
      <Display value={value} />
    </div>
  )
}

// 子組件通過 Props 接收狀態和更新函數
function Input({ value, onChange }: { value: string; onChange: (v: string) => void }) {
  return <input value={value} onChange={e => onChange(e.target.value)} />
}

function Display({ value }: { value: string }) {
  return <p>當前輸入：{value}</p>
}
```

### AI 協作指南

**核心意圖**：讓 AI 幫你設計組件的狀態結構。

**需求定義公式**：
- 功能描述：組件需要記住 [哪些數據]
- 交互方式：用戶可以通過 [操作] 改變狀態
- 預期效果：狀態改變時 UI 如何響應

**關鍵術語**：`useState`、`useReducer`、`dispatch`、狀態提升、函數式更新

**交互策略**：
1. 先讓 AI 分析需要哪些狀態
2. 判斷用 useState 還是 useReducer
3. 實現狀態更新邏輯
4. 處理狀態提升（如需要）

### 避坑指南

1. **State 更新是異步的**：設置後不能立即讀取新值
2. **不要直接修改狀態**：`state.count++` 是錯的，必須用 setter
3. **對象/數組必須創建新引用**：`{...obj}` 或 `[...arr]`
4. **避免過多 useState**：超過 3-4 個考慮用 useReducer 或自定義 Hook

### 驗收清單

- [ ] 正確使用 `'use client'` 聲明
- [ ] 對象/數組狀態更新時創建新引用
- [ ] 依賴前值的更新使用函數式寫法
- [ ] 複雜狀態邏輯使用 useReducer
- [ ] 共享狀態正確提升到公共父組件
