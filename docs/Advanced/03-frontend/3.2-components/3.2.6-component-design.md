---
title: "3.2.6 積木該多大才合適——組件設計：單一職責與組合模式"
typora-root-url: ../../public
---

# 3.2.6 積木該多大才合適——組件設計

### 一句話破題

好的組件像樂高積木——足夠小可以靈活組合，足夠完整可以獨立使用。

### 核心價值

組件設計決定了代碼的可維護性。設計不當的組件要麼過於龐大難以修改，要麼過於碎片化難以理解。

### 單一職責原則

**一個組件應該只有一個變更的理由。**

```tsx
// 錯誤：一個組件承擔太多職責
function UserDashboard() {
  const [user, setUser] = useState(null)
  const [posts, setPosts] = useState([])
  const [notifications, setNotifications] = useState([])
  
  // 獲取用戶數據
  // 獲取帖子數據
  // 獲取通知數據
  // 處理用戶操作
  // 渲染所有內容...
  
  return (/* 數百行 JSX */)
}

// 正確：拆分爲多個專注的組件
function UserDashboard() {
  return (
    <div>
      <UserProfile />
      <UserPosts />
      <NotificationPanel />
    </div>
  )
}
```

### 展示組件 vs 容器組件

| 類型 | 職責 | 特點 |
|------|------|------|
| **展示組件** | 渲染 UI | 接收 Props，無狀態邏輯 |
| **容器組件** | 管理數據 | 處理 state、effects、數據獲取 |

```tsx
// 展示組件：只負責渲染
interface UserCardProps {
  name: string
  avatar: string
  email: string
}

function UserCard({ name, avatar, email }: UserCardProps) {
  return (
    <div className="card">
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  )
}

// 容器組件：負責數據
function UserCardContainer({ userId }: { userId: string }) {
  const { data: user, loading } = useFetch(`/api/users/${userId}`)
  
  if (loading) return <Skeleton />
  return <UserCard {...user} />
}
```

### 組合模式

通過 `children` 和插槽實現靈活組合：

```tsx
// 基礎 Card 組件
interface CardProps {
  children: React.ReactNode
  header?: React.ReactNode
  footer?: React.ReactNode
}

function Card({ children, header, footer }: CardProps) {
  return (
    <div className="card">
      {header && <div className="card-header">{header}</div>}
      <div className="card-body">{children}</div>
      {footer && <div className="card-footer">{footer}</div>}
    </div>
  )
}

// 靈活使用
<Card
  header={<h2>用戶信息</h2>}
  footer={<button>編輯</button>}
>
  <p>姓名：張三</p>
  <p>郵箱：zhang@example.com</p>
</Card>
```

### 複合組件模式

對於複雜 UI，將相關組件組合在一起：

```tsx
// 定義複合組件
const Tabs = ({ children, defaultValue }: TabsProps) => {
  const [activeTab, setActiveTab] = useState(defaultValue)
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabsContext.Provider>
  )
}

Tabs.List = function TabsList({ children }) {
  return <div className="tabs-list">{children}</div>
}

Tabs.Tab = function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useTabsContext()
  return (
    <button 
      className={activeTab === value ? 'active' : ''}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  )
}

Tabs.Panel = function TabPanel({ value, children }) {
  const { activeTab } = useTabsContext()
  if (activeTab !== value) return null
  return <div>{children}</div>
}

// 使用
<Tabs defaultValue="tab1">
  <Tabs.List>
    <Tabs.Tab value="tab1">標籤1</Tabs.Tab>
    <Tabs.Tab value="tab2">標籤2</Tabs.Tab>
  </Tabs.List>
  <Tabs.Panel value="tab1">內容1</Tabs.Panel>
  <Tabs.Panel value="tab2">內容2</Tabs.Panel>
</Tabs>
```

### 組件拆分時機

**需要拆分的信號：**
1. 組件超過 200 行代碼
2. 有明顯獨立的 UI 區塊
3. 邏輯可以被複用
4. 需要獨立測試某部分
5. 多人協作時需要減少衝突

**不需要拆分的情況：**
1. 拆分後只在一處使用
2. 拆分導致 Props 傳遞更復雜
3. 拆分後反而難以理解

### 文件組織

```
components/
├── ui/                    # 通用 UI 組件
│   ├── Button.tsx
│   ├── Card.tsx
│   └── Input.tsx
├── features/              # 業務組件
│   ├── UserProfile/
│   │   ├── index.tsx
│   │   ├── UserAvatar.tsx
│   │   └── UserStats.tsx
│   └── PostList/
│       ├── index.tsx
│       ├── PostCard.tsx
│       └── PostActions.tsx
└── layouts/               # 佈局組件
    ├── Header.tsx
    └── Sidebar.tsx
```

### AI 協作指南

**核心意圖**：讓 AI 幫你分析和重構組件結構。

**需求定義公式**：
- 功能描述：這個組件目前 [做了什麼]
- 交互方式：其中 [哪些部分] 是獨立的
- 預期效果：希望拆分後 [達到什麼效果]

**關鍵術語**：單一職責、展示組件、容器組件、複合組件、組合模式

**交互策略**：
1. 把現有大組件展示給 AI
2. 讓它分析可拆分的邊界
3. 討論拆分方案的利弊
4. 逐步重構

### 避坑指南

1. **不要爲了拆分而拆分**：過度拆分增加理解成本
2. **保持命名一致**：`UserCard`、`UserCardContainer`、`useUserCard`
3. **考慮組件的消費者**：API 設計要符合直覺
4. **避免 Props 爆炸**：超過 7-8 個 Props 考慮重新設計

### 驗收清單

- [ ] 每個組件有清晰的單一職責
- [ ] 展示邏輯和業務邏輯適當分離
- [ ] 使用組合模式實現靈活性
- [ ] 文件組織清晰合理
