---
title: "3.2.5 封裝你自己的積木——自定義 Hooks：邏輯複用與抽象"
typora-root-url: ../../public
---

# 3.2.5 封裝你自己的積木——自定義 Hooks

### 一句話破題

自定義 Hook 是以 `use` 開頭的函數，它讓你將有狀態邏輯提取出來，在多個組件間複用。

### 核心價值

當你發現多個組件有相似的狀態邏輯時，不要複製粘貼——把它提取成自定義 Hook。這不僅減少重複代碼，還讓邏輯更易測試和維護。

### 自定義 Hook 基礎

```tsx
// hooks/useCounter.ts
import { useState, useCallback } from 'react'

export function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue)
  
  const increment = useCallback(() => setCount(c => c + 1), [])
  const decrement = useCallback(() => setCount(c => c - 1), [])
  const reset = useCallback(() => setCount(initialValue), [initialValue])
  
  return { count, increment, decrement, reset }
}

// 使用
function Counter() {
  const { count, increment, decrement } = useCounter(10)
  
  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  )
}
```

### 常用自定義 Hooks 模式

**1. useToggle - 布爾切換**

```tsx
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue)
  
  const toggle = useCallback(() => setValue(v => !v), [])
  const setTrue = useCallback(() => setValue(true), [])
  const setFalse = useCallback(() => setValue(false), [])
  
  return { value, toggle, setTrue, setFalse }
}

// 使用
const { value: isOpen, toggle } = useToggle()
```

**2. useLocalStorage - 持久化存儲**

```tsx
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') return initialValue
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch {
      return initialValue
    }
  })
  
  const setValue = useCallback((value: T | ((val: T) => T)) => {
    setStoredValue(prev => {
      const valueToStore = value instanceof Function ? value(prev) : value
      window.localStorage.setItem(key, JSON.stringify(valueToStore))
      return valueToStore
    })
  }, [key])
  
  return [storedValue, setValue] as const
}
```

**3. useFetch - 數據獲取**

```tsx
interface UseFetchResult<T> {
  data: T | null
  loading: boolean
  error: Error | null
  refetch: () => void
}

function useFetch<T>(url: string): UseFetchResult<T> {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  
  const fetchData = useCallback(async () => {
    setLoading(true)
    setError(null)
    try {
      const res = await fetch(url)
      if (!res.ok) throw new Error('Fetch failed')
      const json = await res.json()
      setData(json)
    } catch (e) {
      setError(e as Error)
    } finally {
      setLoading(false)
    }
  }, [url])
  
  useEffect(() => {
    fetchData()
  }, [fetchData])
  
  return { data, loading, error, refetch: fetchData }
}
```

**4. useDebounce - 防抖**

```tsx
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value)
  
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(timer)
  }, [value, delay])
  
  return debouncedValue
}

// 使用：搜索輸入防抖
function Search() {
  const [query, setQuery] = useState('')
  const debouncedQuery = useDebounce(query, 300)
  
  useEffect(() => {
    if (debouncedQuery) {
      // 發起搜索請求
    }
  }, [debouncedQuery])
}
```

### 命名規範

- **必須以 `use` 開頭**：這是 React 識別 Hook 的方式
- **描述功能而非實現**：`useAuth` 而非 `useAuthState`
- **返回值要一致**：對象用於多返回值，元組用於類似 useState 的場景

### 何時提取自定義 Hook

1. **邏輯重複**：兩個以上組件有相同的狀態邏輯
2. **邏輯複雜**：組件內 Hook 調用超過 5-6 個
3. **關注點分離**：業務邏輯和 UI 邏輯混在一起
4. **便於測試**：需要單獨測試某段邏輯

### AI 協作指南

**核心意圖**：讓 AI 幫你識別和提取可複用的邏輯。

**需求定義公式**：
- 功能描述：我有 [相似邏輯] 在多個組件中重複
- 交互方式：這段邏輯需要 [輸入參數]
- 預期效果：Hook 返回 [哪些數據和方法]

**關鍵術語**：`useCallback`、`useMemo`、泛型、返回類型

**交互策略**：
1. 把重複的代碼展示給 AI
2. 讓它分析可提取的公共邏輯
3. 設計 Hook 的輸入輸出接口
4. 實現並在原組件中使用

### 避坑指南

1. **Hook 規則適用於自定義 Hook**：不能條件調用、循環調用
2. **不要過早抽象**：等邏輯真的重複了再提取
3. **保持 Hook 職責單一**：一個 Hook 做一件事
4. **注意閉包陷阱**：回調函數記得用 useCallback

### 驗收清單

- [ ] Hook 名稱以 `use` 開頭
- [ ] 返回值類型定義清晰
- [ ] 內部回調用 useCallback 包裹
- [ ] 有明確的使用場景和文檔
