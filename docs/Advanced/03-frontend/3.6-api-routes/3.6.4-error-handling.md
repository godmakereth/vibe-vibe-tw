---
title: "3.6.4 統一處理報錯——錯誤處理：統一異常處理機制"
typora-root-url: ../../public
---

# 3.6.4 統一處理報錯——錯誤處理

### 一句話破題

用自定義錯誤類和統一處理器，讓 API 的錯誤響應既對用戶友好，又便於調試。

### 核心價值

分散的 try-catch 讓代碼臃腫，不一致的錯誤格式讓前端抓狂。統一的錯誤處理讓代碼更簡潔，讓錯誤信息更規範。

### 自定義錯誤類

```tsx
// lib/errors.ts

export class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code: string = 'INTERNAL_ERROR'
  ) {
    super(message)
    this.name = this.constructor.name
  }
}

export class NotFoundError extends AppError {
  constructor(message = '資源不存在') {
    super(message, 404, 'NOT_FOUND')
  }
}

export class ValidationError extends AppError {
  constructor(message = '參數驗證失敗', public details?: unknown) {
    super(message, 400, 'VALIDATION_ERROR')
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = '未登錄或登錄已過期') {
    super(message, 401, 'UNAUTHORIZED')
  }
}

export class ForbiddenError extends AppError {
  constructor(message = '無權限執行此操作') {
    super(message, 403, 'FORBIDDEN')
  }
}

export class ConflictError extends AppError {
  constructor(message = '資源衝突') {
    super(message, 409, 'CONFLICT')
  }
}
```

### 統一錯誤處理器

```tsx
// lib/errorHandler.ts

import { AppError } from './errors'
import { Prisma } from '@prisma/client'

interface ErrorResponse {
  error: {
    code: string
    message: string
    details?: unknown
  }
}

export function handleError(error: unknown): Response {
  console.error('API Error:', error)
  
  if (error instanceof AppError) {
    return createErrorResponse(error.statusCode, {
      code: error.code,
      message: error.message,
      details: (error as any).details,
    })
  }
  
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    return handlePrismaError(error)
  }
  
  if (error instanceof Prisma.PrismaClientValidationError) {
    return createErrorResponse(400, {
      code: 'VALIDATION_ERROR',
      message: '數據格式錯誤',
    })
  }
  
  return createErrorResponse(500, {
    code: 'INTERNAL_ERROR',
    message: process.env.NODE_ENV === 'development' 
      ? String(error) 
      : '服務器內部錯誤',
  })
}

function handlePrismaError(error: Prisma.PrismaClientKnownRequestError): Response {
  switch (error.code) {
    case 'P2002':
      const field = (error.meta?.target as string[])?.[0] || '字段'
      return createErrorResponse(409, {
        code: 'CONFLICT',
        message: `${field} 已存在`,
      })
    case 'P2025':
      return createErrorResponse(404, {
        code: 'NOT_FOUND',
        message: '記錄不存在',
      })
    default:
      return createErrorResponse(500, {
        code: 'DATABASE_ERROR',
        message: '數據庫操作失敗',
      })
  }
}

function createErrorResponse(
  status: number, 
  error: ErrorResponse['error']
): Response {
  return Response.json({ error }, { status })
}
```

### 在 API Route 中使用

```tsx
// app/api/posts/[id]/route.ts
import { postService } from '@/services/postService'
import { handleError } from '@/lib/errorHandler'
import { updatePostSchema } from '@/lib/validations/post'

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const post = await postService.findById(params.id)
    return Response.json({ data: post })
  } catch (error) {
    return handleError(error)
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const body = await request.json()
    const result = updatePostSchema.safeParse(body)
    
    if (!result.success) {
      return Response.json(
        { error: { code: 'VALIDATION_ERROR', details: result.error.flatten() } },
        { status: 400 }
      )
    }
    
    const post = await postService.update(params.id, result.data)
    return Response.json({ data: post })
  } catch (error) {
    return handleError(error)
  }
}
```

### 封裝高階函數

進一步簡化 Route Handler：

```tsx
// lib/apiHandler.ts
import { handleError } from './errorHandler'

type ApiHandler = (
  request: Request,
  context?: { params: Record<string, string> }
) => Promise<Response>

export function withErrorHandler(handler: ApiHandler): ApiHandler {
  return async (request, context) => {
    try {
      return await handler(request, context)
    } catch (error) {
      return handleError(error)
    }
  }
}

// 使用
export const GET = withErrorHandler(async (request, { params }) => {
  const post = await postService.findById(params.id)
  return Response.json({ data: post })
})
```

### 錯誤響應格式規範

```tsx
// 統一的錯誤響應格式
{
  "error": {
    "code": "NOT_FOUND",           // 機器可讀的錯誤碼
    "message": "文章不存在",         // 用戶可讀的錯誤信息
    "details": {                    // 可選，詳細信息
      "fieldErrors": {
        "title": ["標題不能爲空"]
      }
    }
  }
}

// 常用錯誤碼
// VALIDATION_ERROR - 參數驗證失敗
// NOT_FOUND - 資源不存在
// UNAUTHORIZED - 未認證
// FORBIDDEN - 無權限
// CONFLICT - 資源衝突
// INTERNAL_ERROR - 服務器錯誤
```

### 日誌記錄

```tsx
// lib/logger.ts
export function logError(error: unknown, context?: Record<string, unknown>) {
  const timestamp = new Date().toISOString()
  const errorInfo = {
    timestamp,
    error: error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: error.stack,
    } : String(error),
    context,
  }
  
  console.error(JSON.stringify(errorInfo))
  
  if (process.env.NODE_ENV === 'production') {
    // 發送到日誌服務
  }
}

// 在 errorHandler 中使用
export function handleError(error: unknown, context?: Record<string, unknown>): Response {
  logError(error, context)
  // ...
}
```

### 前端錯誤處理

配合前端統一處理 API 錯誤：

```tsx
// 前端 API 調用封裝
async function apiRequest<T>(url: string, options?: RequestInit): Promise<T> {
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  })
  
  const data = await response.json()
  
  if (!response.ok) {
    throw new ApiError(data.error.code, data.error.message, response.status)
  }
  
  return data.data
}

// 使用
try {
  const post = await apiRequest('/api/posts/123')
} catch (error) {
  if (error instanceof ApiError) {
    if (error.code === 'NOT_FOUND') {
      // 顯示 404 頁面
    } else {
      // 顯示錯誤提示
      toast.error(error.message)
    }
  }
}
```

### AI 協作指南

**核心意圖**：讓 AI 幫你設計統一的錯誤處理機制。

**需求定義公式**：
- 功能描述：創建統一的錯誤處理系統
- 錯誤類型：[列出需要處理的錯誤類型]
- 響應格式：code + message + details

**關鍵術語**：`AppError`、`handleError`、錯誤碼、日誌記錄

**示例 Prompt**：

```
請創建一個統一的錯誤處理系統：
1. 自定義錯誤類：NotFound、Unauthorized、Forbidden、Conflict
2. 錯誤處理函數：識別不同錯誤類型，返回對應狀態碼
3. 處理 Prisma 錯誤：P2002 唯一約束、P2025 記錄不存在
4. 開發環境顯示詳細錯誤，生產環境隱藏細節
```

### 避坑指南

1. **不要暴露敏感信息**：生產環境不要返回堆棧信息
2. **使用語義化狀態碼**：不要所有錯誤都返回 500
3. **記錄足夠的上下文**：便於排查問題
4. **前後端錯誤碼統一**：定義好文檔

### 驗收清單

- [ ] 有自定義錯誤類體系
- [ ] 有統一的錯誤處理函數
- [ ] 錯誤響應格式一致
- [ ] 有適當的日誌記錄
