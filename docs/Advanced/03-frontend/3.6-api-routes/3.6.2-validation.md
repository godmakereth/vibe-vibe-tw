---
title: "3.6.2 非法請求怎麼攔住——請求驗證：參數校驗與類型安全"
typora-root-url: ../../public
---

# 3.6.2 非法請求怎麼攔住——請求驗證

### 一句話破題

永遠不要信任客戶端傳來的數據——用 Zod 在入口處驗證，把髒數據擋在門外。

### 核心價值

用戶可能手滑、爬蟲可能亂爬、攻擊者可能惡意構造請求。參數驗證是 API 的第一道防線，也是保證類型安全的關鍵。

### 爲什麼選擇 Zod？

| 方案 | 優點 | 缺點 |
|------|------|------|
| **手動校驗** | 無依賴 | 繁瑣、不類型安全 |
| **JSON Schema** | 標準化 | 語法複雜、類型推導差 |
| **Zod** | 類型推導、簡潔、生態好 | 需要額外依賴 |

```tsx
// 手動校驗（繁瑣且不類型安全）
if (!body.title || typeof body.title !== 'string') {
  return Response.json({ error: '標題必填' }, { status: 400 })
}
if (body.title.length < 3) {
  return Response.json({ error: '標題至少3個字符' }, { status: 400 })
}
// ... 還有很多字段

// Zod 校驗（簡潔且類型安全）
const result = schema.safeParse(body)
if (!result.success) {
  return Response.json({ error: result.error }, { status: 400 })
}
// result.data 自動獲得類型
```

### Zod 基礎

**安裝**：

```bash
npm install zod
```

**定義 Schema**：

```tsx
import { z } from 'zod'

// 基礎類型
const stringSchema = z.string()
const numberSchema = z.number()
const booleanSchema = z.boolean()

// 對象 Schema
const userSchema = z.object({
  name: z.string().min(2, '姓名至少2個字符'),
  email: z.string().email('郵箱格式不正確'),
  age: z.number().min(0).max(150).optional(),
})

// 從 Schema 推導 TypeScript 類型
type User = z.infer<typeof userSchema>
// { name: string; email: string; age?: number }
```

### 常用驗證規則

**字符串**：

```tsx
z.string()
  .min(1, '不能爲空')
  .max(100, '最多100個字符')
  .email('郵箱格式不正確')
  .url('URL格式不正確')
  .regex(/^[a-z]+$/, '只能包含小寫字母')
  .trim() // 自動去除首尾空格
  .toLowerCase() // 自動轉小寫
```

**數字**：

```tsx
z.number()
  .min(0, '不能爲負數')
  .max(100, '最大100')
  .int('必須是整數')
  .positive('必須是正數')

// 字符串轉數字（常用於查詢參數）
z.coerce.number()
```

**數組**：

```tsx
z.array(z.string())
  .min(1, '至少選擇一項')
  .max(10, '最多選擇10項')
```

**枚舉**：

```tsx
z.enum(['pending', 'published', 'archived'])

// 或使用 union
z.union([z.literal('pending'), z.literal('published')])
```

**可選與默認值**：

```tsx
z.string().optional()           // string | undefined
z.string().nullable()           // string | null
z.string().default('untitled')  // 默認值
```

### 在 API Route 中使用

```tsx
// lib/validations/post.ts
import { z } from 'zod'

export const createPostSchema = z.object({
  title: z.string().min(3, '標題至少3個字符').max(100),
  content: z.string().min(10, '內容至少10個字符'),
  published: z.boolean().default(false),
  tags: z.array(z.string()).optional(),
})

export const updatePostSchema = createPostSchema.partial()

export const queryPostsSchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(10),
  status: z.enum(['draft', 'published']).optional(),
})

export type CreatePostInput = z.infer<typeof createPostSchema>
```

```tsx
// app/api/posts/route.ts
import { createPostSchema, queryPostsSchema } from '@/lib/validations/post'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const query = Object.fromEntries(searchParams)
  
  const result = queryPostsSchema.safeParse(query)
  if (!result.success) {
    return Response.json(
      { error: result.error.flatten() },
      { status: 400 }
    )
  }
  
  const { page, limit, status } = result.data
  // 現在 page 和 limit 都是 number 類型了
}

export async function POST(request: Request) {
  const body = await request.json()
  
  const result = createPostSchema.safeParse(body)
  if (!result.success) {
    return Response.json(
      { error: result.error.flatten() },
      { status: 400 }
    )
  }
  
  // result.data 類型是 CreatePostInput
  const post = await postService.create(result.data)
  return Response.json(post, { status: 201 })
}
```

### 錯誤信息格式化

```tsx
const result = schema.safeParse(data)

if (!result.success) {
  // 方式一：扁平化錯誤
  const errors = result.error.flatten()
  // {
  //   fieldErrors: { title: ['標題太短'], email: ['郵箱格式不正確'] },
  //   formErrors: []
  // }
  
  // 方式二：格式化錯誤
  const formatted = result.error.format()
  // {
  //   title: { _errors: ['標題太短'] },
  //   email: { _errors: ['郵箱格式不正確'] }
  // }
  
  // 方式三：所有錯誤
  const issues = result.error.issues
  // [{ path: ['title'], message: '標題太短' }, ...]
}
```

### 封裝驗證函數

```tsx
// lib/validate.ts
import { z, ZodSchema } from 'zod'

export function validate<T>(schema: ZodSchema<T>, data: unknown): 
  | { success: true; data: T }
  | { success: false; error: Response } {
  
  const result = schema.safeParse(data)
  
  if (!result.success) {
    return {
      success: false,
      error: Response.json(
        { error: { code: 'VALIDATION_ERROR', details: result.error.flatten() } },
        { status: 400 }
      ),
    }
  }
  
  return { success: true, data: result.data }
}

// 使用
export async function POST(request: Request) {
  const body = await request.json()
  const validation = validate(createPostSchema, body)
  
  if (!validation.success) {
    return validation.error
  }
  
  // validation.data 是類型安全的
}
```

### AI 協作指南

**核心意圖**：讓 AI 生成類型安全的參數驗證。

**需求定義公式**：
- 功能描述：驗證 [資源] 的創建/更新請求
- 字段要求：[字段名]: [類型], [驗證規則]
- 技術要求：使用 Zod，導出類型

**關鍵術語**：`Zod`、`safeParse`、`z.infer`、`flatten`

**示例 Prompt**：

```
請用 Zod 創建用戶註冊的驗證 schema：
- username: 必填，3-20個字符，只能包含字母數字下劃線
- email: 必填，有效郵箱格式
- password: 必填，至少8位，包含大小寫字母和數字
- confirmPassword: 必須與 password 相同
- age: 可選，18-100之間的整數
導出類型和驗證函數
```

### 避坑指南

1. **查詢參數都是字符串**：使用 `z.coerce` 轉換類型
2. **parse vs safeParse**：`parse` 會拋錯，`safeParse` 返回結果對象
3. **partial vs pick**：`partial` 使所有字段可選，`pick` 選擇部分字段
4. **錯誤信息要友好**：提供清晰的中文提示

### 驗收清單

- [ ] 所有 API 入口都有參數驗證
- [ ] 驗證 Schema 與 TypeScript 類型同步
- [ ] 錯誤響應包含清晰的字段級錯誤信息
- [ ] 驗證邏輯可複用（抽離到獨立文件）
