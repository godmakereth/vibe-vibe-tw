---
title: "9.3.2 測試數據放哪——測試數據庫：內存數據庫 vs 真實數據庫"
typora-root-url: ../../public
---

# 9.3.2 測試數據放哪——測試數據庫：內存數據庫 vs 真實數據庫

**測試數據庫的選擇直接影響測試的速度、可靠性和與生產環境的一致性。**

## 方案對比

| 特性 | 真實數據庫 | 內存數據庫 | Mock |
|------|-----------|-----------|------|
| 速度 | 慢 | 快 | 最快 |
| 一致性 | 高 | 中 | 低 |
| 配置複雜度 | 中 | 低 | 高 |
| 發現真實問題 | 高 | 中 | 低 |
| CI 配置 | 需要服務 | 簡單 | 最簡單 |

## 推薦策略

```mermaid
graph TD
    A{測試類型} --> B[單元測試]
    A --> C[集成測試]
    A --> D[E2E 測試]
    
    B --> E[Mock 數據庫]
    C --> F[真實測試數據庫]
    D --> G[真實測試數據庫]
    
    F --> H[本地 PostgreSQL]
    G --> I[Docker PostgreSQL]
```

## 方案一：真實數據庫（推薦）

使用與生產相同類型的數據庫，確保測試結果可信。

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'test' ? [] : ['query'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

```bash
# .env.test
DATABASE_URL="postgresql://test:test@localhost:5432/myapp_test"
```

### Docker 快速啓動測試數據庫

```yaml
# docker-compose.test.yml
version: '3.8'
services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: test
      POSTGRES_PASSWORD: test
      POSTGRES_DB: myapp_test
    ports:
      - "5433:5432"
    tmpfs:
      - /var/lib/postgresql/data
```

```json
// package.json
{
  "scripts": {
    "test:db:up": "docker-compose -f docker-compose.test.yml up -d",
    "test:db:down": "docker-compose -f docker-compose.test.yml down",
    "test": "npm run test:db:up && dotenv -e .env.test -- jest; npm run test:db:down"
  }
}
```

## 方案二：SQLite 內存數據庫

適合快速原型和簡單測試，但與 PostgreSQL 語法有差異。

```prisma
// prisma/schema.test.prisma
datasource db {
  provider = "sqlite"
  url      = "file::memory:?cache=shared"
}
```

```typescript
// 注意：SQLite 不支持某些 PostgreSQL 特性
// - 數組類型
// - JSON 操作
// - 某些日期函數
```

**侷限性**：
- 不支持 PostgreSQL 特有的功能
- 行爲可能與生產環境不一致
- 不推薦用於複雜業務邏輯測試

## 方案三：使用 Prisma Mock

適合純單元測試，不涉及真實數據庫操作。

```typescript
// __mocks__/@prisma/client.ts
import { PrismaClient } from '@prisma/client';
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';

export const prismaMock = mockDeep<PrismaClient>();

beforeEach(() => {
  mockReset(prismaMock);
});

export { prismaMock as PrismaClient };
```

```typescript
// __tests__/services/user.service.test.ts
import { prismaMock } from '@/mocks/@prisma/client';
import { UserService } from '@/services/user.service';

describe('UserService', () => {
  it('應返回用戶', async () => {
    const mockUser = { id: '1', email: 'test@example.com', name: 'Test' };
    prismaMock.user.findUnique.mockResolvedValue(mockUser);
    
    const result = await UserService.getById('1');
    
    expect(result).toEqual(mockUser);
    expect(prismaMock.user.findUnique).toHaveBeenCalledWith({
      where: { id: '1' },
    });
  });
});
```

## 測試數據庫初始化

```typescript
// test/setup-db.ts
import { execSync } from 'child_process';
import { prisma } from '@/lib/prisma';

export async function setupDatabase() {
  // 運行遷移
  execSync('npx prisma migrate deploy', {
    env: { ...process.env },
  });
  
  // 驗證連接
  await prisma.$connect();
}

export async function teardownDatabase() {
  await prisma.$disconnect();
}

export async function resetDatabase() {
  // 按依賴順序清理表
  const tablenames = await prisma.$queryRaw<{ tablename: string }[]>`
    SELECT tablename FROM pg_tables WHERE schemaname='public'
  `;
  
  for (const { tablename } of tablenames) {
    if (tablename !== '_prisma_migrations') {
      await prisma.$executeRawUnsafe(`TRUNCATE TABLE "${tablename}" CASCADE`);
    }
  }
}
```

## GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: myapp_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - run: npm ci
      - run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/myapp_test
      
      - run: npm test
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/myapp_test
```

## 最佳實踐

1. **使用與生產相同的數據庫類型**：避免 SQLite 與 PostgreSQL 的行爲差異
2. **每個測試文件使用獨立事務**：保證測試隔離
3. **CI 中使用 Docker 服務**：確保環境一致性
4. **本地使用 Docker Compose**：簡化環境管理

## 本節小結

測試數據庫的選擇需要權衡速度與一致性。推薦使用與生產相同的數據庫類型（如 PostgreSQL），通過 Docker 管理本地和 CI 環境。Mock 方案適合純單元測試，但不應替代真實數據庫的集成測試。
