---
title: "9.3.1 測試框架怎麼選——Jest 配置：測試框架與斷言庫"
typora-root-url: ../../public
---

# 9.3.1 測試框架怎麼選——Jest 配置：測試框架與斷言庫

**Jest 是 JavaScript 生態中最流行的測試框架，零配置即可使用，功能強大且生態完善。**

## 測試框架對比

| 特性 | Jest | Vitest | Mocha |
|------|------|--------|-------|
| 配置複雜度 | 低 | 低 | 高 |
| 速度 | 中 | 快 | 中 |
| TypeScript | 需 ts-jest | 原生支持 | 需配置 |
| 快照測試 | 內置 | 內置 | 需插件 |
| Mock | 內置 | 內置 | 需插件 |
| 生態 | 最成熟 | 快速成長 | 成熟 |

**推薦**：新項目使用 Vitest（更快），已有 Jest 項目繼續使用 Jest（遷移成本）。

## Jest 完整配置

### 安裝依賴

```bash
npm install -D jest ts-jest @types/jest
```

### 配置文件

```typescript
// jest.config.ts
import type { Config } from 'jest';

const config: Config = {
  // 預設：支持 TypeScript
  preset: 'ts-jest',
  
  // 測試環境：Node.js（服務端）或 jsdom（瀏覽器）
  testEnvironment: 'node',
  
  // 測試文件位置
  roots: ['<rootDir>/src', '<rootDir>/__tests__'],
  
  // 測試文件匹配模式
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/__tests__/**/*.spec.ts',
  ],
  
  // 忽略的目錄
  testPathIgnorePatterns: ['/node_modules/', '/dist/'],
  
  // 路徑別名（與 tsconfig.json 保持一致）
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  
  // 測試前執行的文件
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  
  // 覆蓋率配置
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
  
  // 超時時間（毫秒）
  testTimeout: 10000,
  
  // 清理 Mock
  clearMocks: true,
  restoreMocks: true,
};

export default config;
```

### 初始化文件

```typescript
// jest.setup.ts
import { PrismaClient } from '@prisma/client';

// 全局 Prisma 實例
const prisma = new PrismaClient();

// 測試前連接數據庫
beforeAll(async () => {
  await prisma.$connect();
});

// 測試後斷開連接
afterAll(async () => {
  await prisma.$disconnect();
});

// 擴展 expect 匹配器（可選）
expect.extend({
  toBeWithinRange(received: number, floor: number, ceiling: number) {
    const pass = received >= floor && received <= ceiling;
    return {
      message: () =>
        `expected ${received} ${pass ? 'not ' : ''}to be within range ${floor} - ${ceiling}`,
      pass,
    };
  },
});
```

## 斷言庫使用

### 基礎斷言

```typescript
describe('基礎斷言', () => {
  // 相等性
  it('toBe - 嚴格相等', () => {
    expect(1 + 1).toBe(2);
    expect('hello').toBe('hello');
  });

  it('toEqual - 深度相等', () => {
    expect({ a: 1 }).toEqual({ a: 1 });
    expect([1, 2, 3]).toEqual([1, 2, 3]);
  });

  // 真值判斷
  it('toBeTruthy / toBeFalsy', () => {
    expect(1).toBeTruthy();
    expect(0).toBeFalsy();
    expect(null).toBeFalsy();
  });

  // 數值比較
  it('數值斷言', () => {
    expect(10).toBeGreaterThan(5);
    expect(10).toBeLessThanOrEqual(10);
    expect(0.1 + 0.2).toBeCloseTo(0.3);
  });

  // 字符串匹配
  it('字符串斷言', () => {
    expect('hello world').toContain('world');
    expect('hello world').toMatch(/world$/);
  });

  // 數組包含
  it('數組斷言', () => {
    expect([1, 2, 3]).toContain(2);
    expect([{ id: 1 }, { id: 2 }]).toContainEqual({ id: 1 });
  });
});
```

### 異步斷言

```typescript
describe('異步斷言', () => {
  it('使用 async/await', async () => {
    const result = await fetchData();
    expect(result).toBe('data');
  });

  it('使用 resolves', async () => {
    await expect(fetchData()).resolves.toBe('data');
  });

  it('使用 rejects', async () => {
    await expect(fetchBadData()).rejects.toThrow('Error');
  });
});
```

### 對象匹配

```typescript
describe('對象匹配', () => {
  it('toMatchObject - 部分匹配', () => {
    const user = { id: 1, name: 'John', email: 'john@example.com' };
    
    expect(user).toMatchObject({
      name: 'John',
    });
  });

  it('expect.any - 類型匹配', () => {
    expect({
      id: expect.any(Number),
      name: expect.any(String),
      createdAt: expect.any(Date),
    }).toMatchObject({
      id: 1,
      name: 'John',
      createdAt: new Date(),
    });
  });

  it('expect.objectContaining', () => {
    const response = { success: true, data: { id: 1 }, meta: {} };
    
    expect(response).toEqual(
      expect.objectContaining({
        success: true,
        data: expect.objectContaining({ id: 1 }),
      })
    );
  });
});
```

## 測試組織結構

```typescript
// 使用 describe 分組
describe('OrderService', () => {
  // 嵌套分組
  describe('createOrder', () => {
    // beforeEach 在每個測試前執行
    beforeEach(() => {
      // 準備測試數據
    });

    // afterEach 在每個測試後執行
    afterEach(() => {
      // 清理數據
    });

    it('應創建正常訂單', async () => {
      // 測試邏輯
    });

    it('應拒絕無效訂單', async () => {
      // 測試邏輯
    });

    // 跳過測試
    it.skip('待實現的功能', () => {});

    // 只運行這個測試
    it.only('調試中的測試', () => {});
  });
});
```

## 運行測試

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --runInBand"
  }
}
```

```bash
# 運行所有測試
npm test

# 運行特定文件
npm test -- order.service.test.ts

# 運行匹配的測試
npm test -- --testNamePattern="createOrder"

# 監視模式
npm test -- --watch
```

## 本節小結

Jest 是功能完整的測試框架，內置斷言庫、Mock 和覆蓋率統計。配置時注意路徑別名與 tsconfig.json 保持一致，使用 setupFilesAfterEnv 進行全局初始化。掌握常用斷言方法，讓測試代碼簡潔明瞭。
