---
title: "9.4.2 誰在什麼時間幹了啥——上下文信息：請求 ID/用戶 ID/操作類型"
typora-root-url: ../../public
---

# 9.4.2 誰在什麼時間幹了啥——上下文信息：請求 ID/用戶 ID/操作類型

**沒有上下文的日誌就像沒有時間戳的監控錄像——看得到發生了什麼，但找不到是誰、什麼時候。**

## 上下文信息類型

```mermaid
graph LR
    A[日誌上下文] --> B[請求標識]
    A --> C[用戶標識]
    A --> D[操作信息]
    A --> E[環境信息]
    
    B --> B1[requestId]
    B --> B2[traceId]
    
    C --> C1[userId]
    C --> C2[sessionId]
    
    D --> D1[action]
    D --> D2[resource]
    
    E --> E1[environment]
    E --> E2[version]
```

## 請求 ID 實現

請求 ID 用於追蹤單個請求的完整鏈路。

```typescript
// middleware/request-id.ts
import { nanoid } from 'nanoid';
import { NextRequest, NextResponse } from 'next/server';

export function requestIdMiddleware(request: NextRequest) {
  const requestId = request.headers.get('x-request-id') || nanoid();
  
  const response = NextResponse.next();
  response.headers.set('x-request-id', requestId);
  
  return response;
}
```

```typescript
// lib/logger.ts
import pino from 'pino';
import { AsyncLocalStorage } from 'async_hooks';

interface RequestContext {
  requestId: string;
  userId?: string;
  path?: string;
}

export const contextStorage = new AsyncLocalStorage<RequestContext>();

export const logger = pino({
  mixin() {
    const context = contextStorage.getStore();
    return context ? { ...context } : {};
  },
});
```

```typescript
// middleware/context.ts
import { NextRequest } from 'next/server';
import { contextStorage, logger } from '@/lib/logger';
import { nanoid } from 'nanoid';

export async function withContext<T>(
  request: NextRequest,
  handler: () => Promise<T>
): Promise<T> {
  const requestId = request.headers.get('x-request-id') || nanoid();
  const userId = request.headers.get('x-user-id');
  
  return contextStorage.run(
    {
      requestId,
      userId,
      path: request.nextUrl.pathname,
    },
    handler
  );
}
```

## 使用示例

```typescript
// app/api/orders/route.ts
import { withContext } from '@/middleware/context';
import { logger } from '@/lib/logger';

export async function POST(request: NextRequest) {
  return withContext(request, async () => {
    const body = await request.json();
    
    // 自動包含 requestId、userId、path
    logger.info({ items: body.items.length }, '創建訂單請求');
    
    const order = await orderService.create(body);
    
    logger.info({ orderId: order.id }, '訂單創建成功');
    
    return NextResponse.json(order);
  });
}
```

輸出示例：
```json
{
  "level": 30,
  "time": 1699123456789,
  "requestId": "abc123",
  "userId": "user_456",
  "path": "/api/orders",
  "items": 3,
  "msg": "創建訂單請求"
}
```

## 子日誌器

爲不同模塊創建帶默認上下文的日誌器。

```typescript
// services/order.service.ts
import { logger } from '@/lib/logger';

const log = logger.child({ service: 'order' });

export class OrderService {
  async create(data: CreateOrderInput) {
    log.info({ action: 'create', input: data }, '開始創建訂單');
    
    const order = await prisma.$transaction(async (tx) => {
      // 創建訂單
      const order = await tx.order.create({ data: { ... } });
      
      log.debug({ orderId: order.id }, '訂單記錄已創建');
      
      // 扣減庫存
      await this.deductInventory(tx, data.items);
      
      log.debug({ orderId: order.id }, '庫存已扣減');
      
      return order;
    });
    
    log.info({ 
      action: 'create.success',
      orderId: order.id,
      total: order.total,
    }, '訂單創建成功');
    
    return order;
  }
}
```

## 分佈式追蹤

使用 traceId 追蹤跨服務調用。

```typescript
// lib/tracing.ts
import { logger } from './logger';

export async function callExternalService<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const context = contextStorage.getStore();
  
  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'x-request-id': context?.requestId,
      'x-trace-id': context?.traceId,
    },
  });
  
  logger.debug({
    url,
    status: response.status,
    duration: Date.now() - startTime,
  }, '外部服務調用完成');
  
  return response.json();
}
```

## 標準上下文字段

| 字段 | 描述 | 示例 |
|------|------|------|
| requestId | 請求唯一標識 | `req_abc123` |
| traceId | 分佈式追蹤 ID | `trace_xyz789` |
| userId | 當前用戶 ID | `user_456` |
| sessionId | 會話 ID | `sess_def` |
| action | 操作類型 | `order.create` |
| service | 服務名稱 | `order-service` |
| environment | 運行環境 | `production` |
| version | 應用版本 | `1.2.3` |

## 最佳實踐

```typescript
// ✅ 好：包含完整上下文
logger.info({
  action: 'payment.process',
  orderId,
  amount,
  currency,
  paymentMethod,
}, '開始處理支付');

// ❌ 壞：缺少上下文
logger.info('處理支付');

// ✅ 好：錯誤包含上下文
logger.error({
  err,
  action: 'payment.failed',
  orderId,
  amount,
  retryCount,
}, '支付處理失敗');

// ❌ 壞：只記錄錯誤消息
logger.error('支付失敗');
```

## 本節小結

上下文信息是日誌的"身份證"。通過 requestId 追蹤請求鏈路，通過 userId 定位用戶行爲，通過 action 理解操作類型。使用 AsyncLocalStorage 自動傳遞上下文，讓日誌自動攜帶必要信息。
