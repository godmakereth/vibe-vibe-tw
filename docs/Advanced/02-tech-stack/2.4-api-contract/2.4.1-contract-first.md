---
title: "2.4.1 先商量好再動手——契約先行：API 接口設計優先"
typora-root-url: ../../public
---

# 2.4.1 先商量好再動手——契約先行

## 一句話破題

契約先行的本質是：**在寫任何代碼之前，先用 TypeScript 類型把接口格式定死**。前後端基於同一份類型定義開發，聯調時只需驗證實現是否符合契約。

## 契約的形式

### TypeScript 類型定義

```typescript
// types/api.ts
// 這就是"契約"：請求和響應的格式

// 通用響應格式
interface ApiResponse<T> {
  code: number
  message: string
  data: T
}

// 用戶相關
interface User {
  id: string
  name: string
  email: string
  avatar?: string
  createdAt: string
}

interface CreateUserInput {
  name: string
  email: string
  password: string
}

interface UpdateUserInput {
  name?: string
  avatar?: string
}

// 文章相關
interface Post {
  id: string
  title: string
  content: string
  author: User
  createdAt: string
  updatedAt: string
}

interface CreatePostInput {
  title: string
  content: string
}
```

### Zod Schema（運行時驗證）

```typescript
// schemas/user.ts
import { z } from 'zod'

export const CreateUserSchema = z.object({
  name: z.string().min(2, '姓名至少 2 個字符'),
  email: z.string().email('郵箱格式不正確'),
  password: z.string().min(8, '密碼至少 8 位'),
})

export const UpdateUserSchema = z.object({
  name: z.string().min(2).optional(),
  avatar: z.string().url().optional(),
})

// 從 Zod Schema 導出 TypeScript 類型
export type CreateUserInput = z.infer<typeof CreateUserSchema>
export type UpdateUserInput = z.infer<typeof UpdateUserSchema>
```

## 契約的組織方式

### 目錄結構

```
src/
├── types/
│   ├── api.ts        # 通用 API 類型
│   ├── user.ts       # 用戶相關類型
│   └── post.ts       # 文章相關類型
├── schemas/
│   ├── user.ts       # 用戶驗證 Schema
│   └── post.ts       # 文章驗證 Schema
└── app/
    └── api/
        └── users/
            └── route.ts  # API 實現
```

### 完整的契約文件示例

```typescript
// types/user.ts

// ============ 實體類型 ============
export interface User {
  id: string
  name: string
  email: string
  avatar: string | null
  role: 'admin' | 'user'
  createdAt: string
  updatedAt: string
}

// ============ 請求類型 ============
export interface CreateUserRequest {
  name: string
  email: string
  password: string
}

export interface UpdateUserRequest {
  name?: string
  avatar?: string
}

export interface ListUsersRequest {
  page?: number
  pageSize?: number
  search?: string
}

// ============ 響應類型 ============
export interface UserResponse {
  code: number
  message: string
  data: User
}

export interface UsersListResponse {
  code: number
  message: string
  data: {
    users: User[]
    total: number
    page: number
    pageSize: number
  }
}
```

## 前後端如何使用契約

### 後端實現

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { CreateUserSchema } from '@/schemas/user'
import type { UserResponse, CreateUserRequest } from '@/types/user'

export async function POST(request: NextRequest) {
  const body: CreateUserRequest = await request.json()
  
  // 使用 Zod 驗證
  const validated = CreateUserSchema.safeParse(body)
  if (!validated.success) {
    return NextResponse.json({
      code: 400,
      message: '參數錯誤',
      errors: validated.error.flatten().fieldErrors,
    }, { status: 400 })
  }
  
  // 創建用戶
  const user = await prisma.user.create({
    data: validated.data,
  })
  
  // 返回符合契約的響應
  const response: UserResponse = {
    code: 200,
    message: '創建成功',
    data: user,
  }
  
  return NextResponse.json(response)
}
```

### 前端調用

```typescript
// services/user.ts
import type { 
  CreateUserRequest, 
  UserResponse,
  UsersListResponse 
} from '@/types/user'

export async function createUser(data: CreateUserRequest): Promise<UserResponse> {
  const res = await fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  })
  return res.json()
}

export async function getUsers(params?: { page?: number }): Promise<UsersListResponse> {
  const searchParams = new URLSearchParams()
  if (params?.page) searchParams.set('page', String(params.page))
  
  const res = await fetch(`/api/users?${searchParams}`)
  return res.json()
}
```

## API 設計規範

### RESTful 風格

| 操作 | HTTP 方法 | URL | 示例 |
|------|-----------|-----|------|
| 列表 | GET | /api/users | 獲取用戶列表 |
| 詳情 | GET | /api/users/:id | 獲取單個用戶 |
| 創建 | POST | /api/users | 創建用戶 |
| 更新 | PUT/PATCH | /api/users/:id | 更新用戶 |
| 刪除 | DELETE | /api/users/:id | 刪除用戶 |

### 響應格式統一

```typescript
// 成功響應
{
  "code": 200,
  "message": "操作成功",
  "data": { ... }
}

// 錯誤響應
{
  "code": 400,
  "message": "參數錯誤",
  "errors": {
    "email": ["郵箱格式不正確"]
  }
}

// 分頁響應
{
  "code": 200,
  "message": "獲取成功",
  "data": {
    "items": [...],
    "total": 100,
    "page": 1,
    "pageSize": 10
  }
}
```

## 覺知：契約設計的常見問題

### 1. 類型過於寬泛

```typescript
// ❌ 太寬泛，AI 不知道具體格式
interface ApiResponse {
  data: any
}

// ✅ 明確的類型定義
interface UserResponse {
  code: number
  message: string
  data: User
}
```

### 2. 請求和響應類型混用

```typescript
// ❌ 創建時不應該有 id
interface User {
  id: string
  name: string
}
// 創建用戶時也要傳 id？

// ✅ 分離輸入和輸出類型
interface User {
  id: string
  name: string
}

interface CreateUserInput {
  name: string  // 創建時不需要 id
}
```

### 3. 可選字段濫用

```typescript
// ❌ 全部可選，契約形同虛設
interface CreateUserInput {
  name?: string
  email?: string
}

// ✅ 必填和可選分明
interface CreateUserInput {
  name: string   // 必填
  email: string  // 必填
  avatar?: string  // 可選
}
```

## AI 協作指南

**核心意圖**：讓 AI 基於契約生成代碼

**關鍵術語**：`TypeScript 類型`、`Zod Schema`、`API 契約`、`請求類型`、`響應類型`

**交互策略**：
1. 先給 AI 看類型定義文件
2. 告訴 AI："基於這個類型定義，幫我實現 API"
3. AI 生成的代碼會自動符合契約

```
示例 Prompt：
"基於 types/user.ts 中的 CreateUserRequest 和 UserResponse 類型，
幫我實現 POST /api/users 接口，使用 Prisma 操作數據庫"
```

## 本節小結

| 原則 | 說明 |
|------|------|
| 類型先行 | 寫代碼前先定義 TypeScript 類型 |
| 單一數據源 | 類型定義集中管理，前後端共用 |
| 輸入輸出分離 | CreateInput 和 Entity 是不同的類型 |
| 運行時驗證 | 用 Zod 在運行時驗證數據 |
