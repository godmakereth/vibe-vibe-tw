---
title: "6.3.5 API 限流與防護：請求頻率控制與異常檢測"
typora-root-url: ../../public
---

# 6.3.5 API 限流與防護

## 本質還原

限流的本質是：**控制資源消耗速率，防止服務被打垮**。無論是惡意攻擊還是意外流量高峯，限流都是保護系統的最後一道防線。

```mermaid
flowchart LR
    Request["大量請求"] --> RateLimit["限流器"]
    RateLimit -->|通過| Server["服務器"]
    RateLimit -->|拒絕| Block["429 Too Many Requests"]
```

## 常見限流算法

### 1. 固定窗口

按時間窗口計數，窗口結束後重置。

```
時間窗口: |----1分鐘----|----1分鐘----|
請求計數:      58         12
限制:         60次/分鐘
```

缺點：窗口邊界可能出現突發流量（前一窗口末尾 + 後一窗口開頭）。

### 2. 滑動窗口

將窗口滑動計算，更平滑地控制流量。

```typescript
// 滑動窗口限流示例
function slidingWindowRateLimit(
  requests: number[],  // 最近請求的時間戳
  windowMs: number,    // 窗口大小（毫秒）
  maxRequests: number  // 窗口內最大請求數
): boolean {
  const now = Date.now()
  const windowStart = now - windowMs
  
  // 只統計窗口內的請求
  const recentRequests = requests.filter(t => t > windowStart)
  return recentRequests.length < maxRequests
}
```

### 3. 令牌桶

以固定速率向桶中添加令牌，每個請求消耗一個令牌。桶滿時多餘令牌被丟棄。

優點：允許一定程度的突發流量（桶中積累的令牌）。

## Next.js 實現限流

### 使用 Upstash Redis

```bash
pnpm add @upstash/ratelimit @upstash/redis
```

```typescript
// lib/ratelimit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

export const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'),  // 10秒10次
  analytics: true,
  prefix: 'ratelimit',
})
```

```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { ratelimit } from './lib/ratelimit'

export async function middleware(request: NextRequest) {
  // 只對 API 路由限流
  if (request.nextUrl.pathname.startsWith('/api')) {
    const ip = request.ip ?? '127.0.0.1'
    const { success, limit, reset, remaining } = await ratelimit.limit(ip)
    
    if (!success) {
      return NextResponse.json(
        { error: '請求過於頻繁，請稍後再試' },
        {
          status: 429,
          headers: {
            'X-RateLimit-Limit': limit.toString(),
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': reset.toString(),
          },
        }
      )
    }
  }
  
  return NextResponse.next()
}
```

### 內存限流（無依賴方案）

適用於單實例部署：

```typescript
// lib/memory-ratelimit.ts
const requests = new Map<string, number[]>()

export function rateLimit(
  key: string,
  limit: number = 10,
  windowMs: number = 60000
): { success: boolean; remaining: number } {
  const now = Date.now()
  const windowStart = now - windowMs
  
  // 獲取該 key 的請求記錄
  let timestamps = requests.get(key) || []
  
  // 清理過期記錄
  timestamps = timestamps.filter(t => t > windowStart)
  
  if (timestamps.length >= limit) {
    return { success: false, remaining: 0 }
  }
  
  // 記錄本次請求
  timestamps.push(now)
  requests.set(key, timestamps)
  
  return { success: true, remaining: limit - timestamps.length }
}

// 定期清理過期數據
setInterval(() => {
  const now = Date.now()
  for (const [key, timestamps] of requests.entries()) {
    const valid = timestamps.filter(t => t > now - 60000)
    if (valid.length === 0) {
      requests.delete(key)
    } else {
      requests.set(key, valid)
    }
  }
}, 60000)
```

## 分級限流策略

針對不同接口設置不同限制：

```typescript
// lib/ratelimit-config.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = Redis.fromEnv()

// 普通接口：每分鐘 60 次
export const standardLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(60, '1 m'),
  prefix: 'standard',
})

// 認證接口：每小時 10 次（防暴力破解）
export const authLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '1 h'),
  prefix: 'auth',
})

// 高頻接口：每秒 100 次
export const highFreqLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, '1 s'),
  prefix: 'highfreq',
})
```

```typescript
// app/api/login/route.ts
import { authLimit } from '@/lib/ratelimit-config'

export async function POST(request: Request) {
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown'
  const { success } = await authLimit.limit(ip)
  
  if (!success) {
    return Response.json(
      { error: '登錄嘗試次數過多，請 1 小時後再試' },
      { status: 429 }
    )
  }
  
  // 繼續登錄邏輯
}
```

## 異常檢測與響應

### 監控可疑行爲

```typescript
// lib/anomaly-detection.ts
interface RequestPattern {
  ip: string
  userAgent: string
  path: string
  timestamp: number
}

const patterns: RequestPattern[] = []

export function detectAnomaly(request: Request): boolean {
  const ip = request.headers.get('x-forwarded-for') ?? 'unknown'
  const userAgent = request.headers.get('user-agent') ?? ''
  const path = new URL(request.url).pathname
  
  // 記錄請求模式
  patterns.push({ ip, userAgent, path, timestamp: Date.now() })
  
  // 檢測異常模式
  const recentFromIp = patterns.filter(
    p => p.ip === ip && p.timestamp > Date.now() - 60000
  )
  
  // 1. 短時間內大量不同路徑請求（可能是掃描）
  const uniquePaths = new Set(recentFromIp.map(p => p.path))
  if (uniquePaths.size > 50) {
    return true  // 異常
  }
  
  // 2. 可疑 User-Agent
  if (!userAgent || userAgent.includes('bot') || userAgent.includes('curl')) {
    // 可能是爬蟲或自動化工具
  }
  
  return false
}
```

### 漸進式響應

```typescript
// 根據違規次數採取不同措施
async function handleRateLimitViolation(ip: string, violations: number) {
  if (violations === 1) {
    // 第一次：警告
    return Response.json(
      { error: '請求頻率過高，請放慢速度' },
      { status: 429 }
    )
  } else if (violations < 5) {
    // 多次違規：增加等待時間
    return Response.json(
      { error: `請等待 ${violations * 60} 秒後重試` },
      { status: 429, headers: { 'Retry-After': (violations * 60).toString() } }
    )
  } else {
    // 嚴重違規：加入黑名單
    await addToBlacklist(ip)
    return Response.json(
      { error: '您的 IP 已被暫時封禁' },
      { status: 403 }
    )
  }
}
```

## 配置清單

::: tip 限流配置建議
| 接口類型 | 建議限制 | 說明 |
|----------|----------|------|
| 登錄/註冊 | 10次/小時 | 防暴力破解 |
| 短信驗證碼 | 5次/小時 | 防濫用 |
| 普通 API | 60次/分鐘 | 正常使用夠用 |
| 搜索接口 | 30次/分鐘 | 防止爬蟲 |
| 文件上傳 | 10次/小時 | 防止濫用存儲 |
:::

::: warning 限流安全清單
1. [ ] 所有 API 都配置了基礎限流
2. [ ] 敏感接口（登錄、支付）有更嚴格限制
3. [ ] 返回標準的 429 狀態碼和 Retry-After 頭
4. [ ] 記錄被限流的請求用於分析
5. [ ] 對重複違規 IP 實施漸進式懲罰
:::
