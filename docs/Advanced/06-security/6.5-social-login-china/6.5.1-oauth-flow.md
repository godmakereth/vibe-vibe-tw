---
title: "6.5.1 OAuth 2.0 是什麼——OAuth 2.0 流程：授權碼模式詳解"
typora-root-url: ../../public
---

# 6.5.1 OAuth 2.0 流程：授權碼模式詳解

## 一句話破題

OAuth 2.0 解決的問題是：**讓用戶授權第三方應用訪問自己的數據，但不暴露密碼**。授權碼模式是最安全的標準流程。

## 核心價值

理解 OAuth 2.0 能讓你：
- 明白所有第三方登錄的底層原理
- 無論接入哪個平臺都能快速上手
- 排查登錄失敗時知道問題出在哪

## 授權碼模式流程

```mermaid
sequenceDiagram
    participant User as 用戶瀏覽器
    participant App as 你的應用
    participant Auth as 授權服務器
    participant API as 資源服務器
    
    User->>App: 1. 點擊"微信登錄"
    App->>User: 2. 重定向到授權頁面
    User->>Auth: 3. 跳轉到微信授權頁
    Auth->>User: 4. 顯示授權確認頁面
    User->>Auth: 5. 用戶確認授權
    Auth->>User: 6. 重定向回應用（帶 code）
    User->>App: 7. 攜帶授權碼訪問回調 URL
    App->>Auth: 8. 用 code 換 access_token
    Auth->>App: 9. 返回 access_token
    App->>API: 10. 用 token 獲取用戶信息
    API->>App: 11. 返回用戶信息
    App->>User: 12. 登錄成功
```

## 快速上手

### 步驟一：構建授權 URL

```typescript
// app/api/auth/wechat/route.ts
export async function GET() {
  const params = new URLSearchParams({
    appid: process.env.WECHAT_APP_ID!,
    redirect_uri: encodeURIComponent('https://your-site.com/api/auth/wechat/callback'),
    response_type: 'code',
    scope: 'snsapi_login',
    state: generateSecureState(),  // 防 CSRF
  })
  
  const authUrl = `https://open.weixin.qq.com/connect/qrconnect?${params}#wechat_redirect`
  return Response.redirect(authUrl)
}
```

### 步驟二：處理回調

```typescript
// app/api/auth/wechat/callback/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const code = searchParams.get('code')
  const state = searchParams.get('state')
  
  // 驗證 state 防止 CSRF
  if (!verifyState(state)) {
    return Response.redirect('/login?error=invalid_state')
  }
  
  // 用 code 換 access_token
  const tokenRes = await fetch(
    `https://api.weixin.qq.com/sns/oauth2/access_token?` +
    `appid=${process.env.WECHAT_APP_ID}` +
    `&secret=${process.env.WECHAT_APP_SECRET}` +
    `&code=${code}` +
    `&grant_type=authorization_code`
  )
  
  const { access_token, openid } = await tokenRes.json()
  
  // 獲取用戶信息
  const userRes = await fetch(
    `https://api.weixin.qq.com/sns/userinfo?access_token=${access_token}&openid=${openid}`
  )
  
  const userInfo = await userRes.json()
  
  // 創建或查找本地用戶，建立會話
  // ...
}
```

### 步驟三：State 參數防護

```typescript
import { cookies } from 'next/headers'
import { randomBytes } from 'crypto'

export function generateSecureState(): string {
  const state = randomBytes(32).toString('hex')
  cookies().set('oauth_state', state, {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 60 * 10,  // 10 分鐘有效
  })
  return state
}

export function verifyState(state: string | null): boolean {
  const stored = cookies().get('oauth_state')?.value
  cookies().delete('oauth_state')
  return !!state && state === stored
}
```

## 關鍵參數說明

| 參數 | 說明 | 示例 |
|------|------|------|
| `client_id` | 應用的唯一標識 | `wx1234567890abcdef` |
| `redirect_uri` | 授權後跳轉的回調地址 | `https://example.com/callback` |
| `response_type` | 固定爲 `code` | `code` |
| `scope` | 請求的權限範圍 | `snsapi_login` |
| `state` | 防 CSRF 的隨機字符串 | `abc123xyz` |

## 避坑指南

::: danger 新手最容易犯的錯
1. 忘記驗證 `state` 參數——導致 CSRF 漏洞
2. `redirect_uri` 與註冊時不一致——授權失敗
3. 在前端暴露 `client_secret`——嚴重安全問題
4. 沒有處理授權被拒絕的情況——用戶體驗差
:::
