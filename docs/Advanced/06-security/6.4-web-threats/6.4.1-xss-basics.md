---
title: "6.4.1 XSS：輸入驗證與輸出編碼"
typora-root-url: ../../public
---

# 6.4.1 XSS：輸入驗證與輸出編碼

## 一句話破題

XSS 攻擊就是讓你的網站幫攻擊者執行 JavaScript 代碼。防禦的關鍵是：**進來的要驗證，出去的要編碼**。

## 核心價值

理解 XSS 能讓你：
- 避免用戶數據被盜
- 保護用戶賬戶安全
- 通過安全審計

## 快速上手

### React 默認防護

React 會自動轉義 JSX 中的內容，這是第一道防線：

```tsx
function Comment({ content }) {
  // ✅ 安全：React 自動轉義
  return <div>{content}</div>
}
```

### 需要警惕的場景

```tsx
// ❌ 危險：繞過 React 防護
<div dangerouslySetInnerHTML={{ __html: userContent }} />

// ❌ 危險：動態創建腳本
const script = document.createElement('script')
script.src = userInput
document.body.appendChild(script)

// ❌ 危險：eval 執行
eval(userInput)
```

### 使用 DOMPurify 清理 HTML

當確實需要渲染用戶 HTML 時：

```typescript
import DOMPurify from 'isomorphic-dompurify'

function SafeHtml({ html }) {
  const clean = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'b', 'i', 'em', 'strong', 'a'],
    ALLOWED_ATTR: ['href'],
  })
  
  return <div dangerouslySetInnerHTML={{ __html: clean }} />
}
```

### 配置 CSP 響應頭

Content Security Policy 限制可執行的腳本來源：

```typescript
// next.config.js
module.exports = {
  async headers() {
    return [{
      source: '/:path*',
      headers: [{
        key: 'Content-Security-Policy',
        value: "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'"
      }]
    }]
  }
}
```

## 避坑指南

::: danger 新手最容易犯的錯
1. 認爲"我只是展示用戶輸入，不會有問題"——展示本身就是執行的入口
2. 使用 `innerHTML` 或 `dangerouslySetInnerHTML` 卻不清理內容
3. 在 URL 參數中插入未驗證的數據
:::
