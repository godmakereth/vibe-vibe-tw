---
title: "6.4.2 CSRF：令牌驗證與 SameSite"
typora-root-url: ../../public
---

# 6.4.2 CSRF：令牌驗證與 SameSite

## 一句話破題

CSRF 攻擊就是借用你的登錄身份，讓你的瀏覽器替攻擊者發請求。防禦的關鍵是：**讓服務器能區分"你主動發的請求"和"被騙發的請求"**。

## 核心價值

理解 CSRF 能讓你：
- 保護用戶的敏感操作不被冒用
- 避免"代替用戶轉賬"類的安全事故
- 理解爲什麼現代框架要這樣設計

## 快速上手

### 方案一：SameSite Cookie（最簡單）

現代瀏覽器支持 SameSite 屬性，自動阻止跨站請求攜帶 Cookie：

```typescript
// NextAuth 配置
cookies: {
  sessionToken: {
    options: {
      sameSite: 'lax',  // 推薦：阻止跨站 POST 請求
      secure: true,
      httpOnly: true,
    }
  }
}
```

### 方案二：CSRF Token

在表單中嵌入隨機令牌，提交時驗證：

```tsx
// 服務端生成 token
import { randomBytes } from 'crypto'
const csrfToken = randomBytes(32).toString('hex')

// 表單中包含 token
<form action={submitForm}>
  <input type="hidden" name="csrf" value={csrfToken} />
  <button>提交</button>
</form>

// 服務端驗證
export async function submitForm(formData: FormData) {
  const token = formData.get('csrf')
  if (token !== session.csrfToken) {
    throw new Error('CSRF 驗證失敗')
  }
}
```

### 方案三：驗證 Origin 頭

```typescript
export async function POST(request: Request) {
  const origin = request.headers.get('origin')
  if (origin !== 'https://your-domain.com') {
    return Response.json({ error: '非法請求' }, { status: 403 })
  }
}
```

## Next.js Server Actions 的內置保護

使用 Server Actions 時，Next.js 已自動處理 CSRF：

```typescript
'use server'

export async function createOrder(formData: FormData) {
  // Server Actions 自動驗證請求來源
  // 你只需關注業務邏輯
}
```

## 避坑指南

::: danger 新手最容易犯的錯
1. 用 GET 請求執行敏感操作（如 `/api/delete?id=1`）
2. 忘記在 Cookie 上設置 SameSite 屬性
3. 使用 API Routes 時忘記手動添加 CSRF 保護
:::
