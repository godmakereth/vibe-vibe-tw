---
title: "7.1.2 數據的格式——JSON 數據格式：序列化與反序列化"
typora-root-url: ../../public
---

# 7.1.2 JSON 數據格式

## 一句話破題

JSON 是前後端交流的"普通話"——瀏覽器認識它，服務器認識它，幾乎所有編程語言都能讀寫它。

## JSON 基礎

```json
{
  "id": 1,
  "name": "Alice",
  "email": "alice@example.com",
  "age": 25,
  "isActive": true,
  "tags": ["developer", "designer"],
  "profile": {
    "avatar": "avatar.png",
    "bio": "Hello world"
  },
  "createdAt": "2024-01-15T10:30:00Z"
}
```

### 支持的數據類型

| 類型 | 示例 | 注意事項 |
|------|------|----------|
| **字符串** | `"hello"` | 必須用雙引號 |
| **數字** | `123`, `3.14` | 不支持 NaN、Infinity |
| **布爾** | `true`, `false` | 小寫 |
| **null** | `null` | 表示空值 |
| **數組** | `[1, 2, 3]` | 有序列表 |
| **對象** | `{"key": "value"}` | 鍵值對 |

### 不支持的類型

```typescript
// ❌ 這些類型 JSON 不支持
const data = {
  date: new Date(),      // Date 對象
  fn: () => {},          // 函數
  undef: undefined,      // undefined
  symbol: Symbol('x'),   // Symbol
  bigint: 123n,          // BigInt
}

// 序列化後：
JSON.stringify(data)
// { "date": "2024-01-15T10:30:00.000Z" }
// 函數、undefined、Symbol 會被忽略
// BigInt 會報錯
```

## 序列化與反序列化

```mermaid
flowchart LR
    subgraph JS["JavaScript 對象"]
        O["{ name: 'Alice' }"]
    end
    
    subgraph JSON["JSON 字符串"]
        S['"{\\"name\\":\\"Alice\\"}"']
    end
    
    O -->|"JSON.stringify()"| S
    S -->|"JSON.parse()"| O
```

### 基本用法

```typescript
// 序列化：對象 → 字符串
const user = { name: 'Alice', age: 25 }
const jsonString = JSON.stringify(user)
// '{"name":"Alice","age":25}'

// 反序列化：字符串 → 對象
const parsed = JSON.parse(jsonString)
// { name: 'Alice', age: 25 }
```

### 處理日期

```typescript
// 問題：Date 序列化後變成字符串
const data = { createdAt: new Date() }
const json = JSON.stringify(data)
// '{"createdAt":"2024-01-15T10:30:00.000Z"}'

const parsed = JSON.parse(json)
parsed.createdAt  // 字符串，不是 Date！

// 解決方案 1：使用 reviver 函數
const parsed2 = JSON.parse(json, (key, value) => {
  if (key === 'createdAt') {
    return new Date(value)
  }
  return value
})

// 解決方案 2：使用 superjson（推薦）
import superjson from 'superjson'

const json2 = superjson.stringify({ date: new Date() })
const parsed3 = superjson.parse(json2)
// parsed3.date 是真正的 Date 對象
```

## API 響應格式規範

### 統一的響應結構

```typescript
// 成功響應
interface SuccessResponse<T> {
  success: true
  data: T
}

// 列表響應（帶分頁）
interface ListResponse<T> {
  success: true
  data: T[]
  pagination: {
    page: number
    pageSize: number
    total: number
    totalPages: number
  }
}

// 錯誤響應
interface ErrorResponse {
  success: false
  error: {
    code: string
    message: string
  }
}
```

### 實際示例

```typescript
// 獲取單個用戶
// GET /api/users/123
{
  "success": true,
  "data": {
    "id": "123",
    "name": "Alice",
    "email": "alice@example.com"
  }
}

// 獲取用戶列表
// GET /api/users?page=1&pageSize=10
{
  "success": true,
  "data": [
    { "id": "1", "name": "Alice" },
    { "id": "2", "name": "Bob" }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 10,
    "total": 100,
    "totalPages": 10
  }
}

// 錯誤響應
// GET /api/users/999
{
  "success": false,
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "用戶不存在"
  }
}
```

## 命名規範

### 前端常用 camelCase

```typescript
// 前端 TypeScript
interface User {
  userId: string
  firstName: string
  lastName: string
  createdAt: string
}
```

### 後端可能用 snake_case

```python
# Python/數據庫
{
  "user_id": "123",
  "first_name": "Alice",
  "last_name": "Smith",
  "created_at": "2024-01-15T10:30:00Z"
}
```

### 轉換方案

```typescript
// 使用庫進行轉換
import camelcaseKeys from 'camelcase-keys'
import snakecaseKeys from 'snakecase-keys'

// 接收數據時：snake_case → camelCase
const apiResponse = await fetch('/api/users')
const data = camelcaseKeys(await apiResponse.json(), { deep: true })

// 發送數據時：camelCase → snake_case
const body = snakecaseKeys(userData, { deep: true })
await fetch('/api/users', {
  method: 'POST',
  body: JSON.stringify(body),
})
```

## 覺知：常見問題

### 1. 循環引用

```typescript
// ❌ 會報錯
const obj: any = { name: 'Alice' }
obj.self = obj  // 循環引用

JSON.stringify(obj)  // TypeError: Converting circular structure to JSON
```

### 2. 忘記設置 Content-Type

```typescript
// ❌ 服務器可能無法正確解析
fetch('/api/users', {
  method: 'POST',
  body: JSON.stringify(data),
})

// ✅ 必須設置 Content-Type
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(data),
})
```

### 3. 數字精度丟失

```typescript
// 大數字可能丟失精度
const bigNumber = 9007199254740993  // 超出 JS 安全整數範圍
JSON.parse('{"id": 9007199254740993}')
// { id: 9007199254740992 }  精度丟失！

// 解決方案：用字符串傳遞大數字
{ "id": "9007199254740993" }
```

## 本節小結

| 要點 | 說明 |
|------|------|
| **JSON.stringify** | 對象轉字符串 |
| **JSON.parse** | 字符串轉對象 |
| **Date 處理** | 需要手動轉換或用 superjson |
| **Content-Type** | 發送 JSON 必須設置 |
| **命名規範** | 前後端約定一致 |
