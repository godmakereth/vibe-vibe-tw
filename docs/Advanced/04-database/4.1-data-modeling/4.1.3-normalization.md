---
title: "4.1.3 數據表的設計規則——範式理論：1NF/2NF/3NF 規範化過程"
typora-root-url: ../../public
---

# 4.1.3 數據表的設計規則——範式理論：1NF/2NF/3NF 規範化過程

### 一句話破題

範式是數據庫設計的"衛生標準"——遵守它能避免數據冗餘和更新異常。

### 爲什麼需要範式？

**不規範的表設計會帶來三大問題**：

| 問題 | 說明 | 示例 |
|------|------|------|
| **數據冗餘** | 相同信息重複存儲 | 每條訂單都存儲完整的客戶地址 |
| **更新異常** | 修改數據需要改多處 | 客戶改地址，要更新所有相關訂單 |
| **刪除異常** | 刪數據可能丟失有用信息 | 刪除唯一訂單時，客戶信息也沒了 |

### 三大範式速覽

```mermaid
graph LR
    A["1NF: 原子性"] --> B["2NF: 完全依賴"]
    B --> C["3NF: 消除傳遞依賴"]
```

| 範式 | 核心要求 | 通俗解釋 |
|------|----------|----------|
| **1NF** | 字段不可再分 | 一個格子只放一個值 |
| **2NF** | 非主鍵完全依賴主鍵 | 所有字段都跟主鍵直接相關 |
| **3NF** | 消除傳遞依賴 | 字段之間不要"套娃"依賴 |

### 第一範式：原子性

**規則**：每個字段的值必須是不可再分的原子值。

**反例**：

| 訂單ID | 商品列表 |
|--------|----------|
| 001 | 蘋果,香蕉,橙子 |

**正確做法**：

| 訂單ID | 商品 |
|--------|------|
| 001 | 蘋果 |
| 001 | 香蕉 |
| 001 | 橙子 |

或者使用關聯表：

```prisma
model Order {
  id    String      @id
  items OrderItem[]
}

model OrderItem {
  id       String @id
  orderId  String
  product  String
  quantity Int
  order    Order  @relation(fields: [orderId], references: [id])
}
```

### 第二範式：完全依賴

**規則**：非主鍵字段必須完全依賴於主鍵，不能只依賴主鍵的一部分。

**反例**（複合主鍵場景）：

| 學生ID | 課程ID | 學生姓名 | 課程名稱 | 成績 |
|--------|--------|----------|----------|------|
| S001 | C001 | 張三 | 數學 | 90 |

問題：`學生姓名`只依賴`學生ID`，`課程名稱`只依賴`課程ID`。

**正確做法**：拆分成三張表

```prisma
model Student {
  id      String   @id
  name    String
  scores  Score[]
}

model Course {
  id      String   @id
  name    String
  scores  Score[]
}

model Score {
  studentId String
  courseId  String
  score     Int
  student   Student @relation(fields: [studentId], references: [id])
  course    Course  @relation(fields: [courseId], references: [id])
  
  @@id([studentId, courseId])
}
```

### 第三範式：消除傳遞依賴

**規則**：非主鍵字段不能依賴於其他非主鍵字段。

**反例**：

| 員工ID | 員工姓名 | 部門ID | 部門名稱 | 部門地址 |
|--------|----------|--------|----------|----------|
| E001 | 張三 | D001 | 技術部 | 3樓 |

問題：`部門名稱`和`部門地址`依賴於`部門ID`，而不是直接依賴於`員工ID`。

**正確做法**：

```prisma
model Employee {
  id           String     @id
  name         String
  departmentId String
  department   Department @relation(fields: [departmentId], references: [id])
}

model Department {
  id        String     @id
  name      String
  location  String
  employees Employee[]
}
```

### 規範化的實際效果

**規範化前**：訂單表存儲冗餘客戶信息

```
訂單表：
| 訂單ID | 客戶ID | 客戶姓名 | 客戶地址 | 商品 | 金額 |
```

**規範化後**：

```prisma
model Order {
  id         String   @id
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])
  items      OrderItem[]
  total      Decimal
}

model Customer {
  id      String  @id
  name    String
  address String
  orders  Order[]
}
```

### 範式檢查清單

設計表時，逐項檢查：

- [ ] **1NF**：所有字段都是原子值？沒有數組或逗號分隔的值？
- [ ] **2NF**：所有非主鍵字段都依賴於完整的主鍵？
- [ ] **3NF**：非主鍵字段之間沒有依賴關係？

### 實際開發中的權衡

範式理論是**理想狀態**，實際開發中需要權衡：

| 嚴格遵守範式 | 適度違反範式 |
|--------------|--------------|
| 數據一致性好 | 查詢性能更高 |
| 存儲空間小 | 減少 JOIN 操作 |
| 更新方便 | 代碼更簡單 |

**建議**：先按範式設計，遇到性能瓶頸再考慮反範式化（下一節詳述）。

### 本節小結

- 1NF：字段值不可再分
- 2NF：非主鍵完全依賴主鍵
- 3NF：消除傳遞依賴
- 遵守範式能避免數據冗餘和更新異常
- 實際開發中需要在規範和性能之間權衡
