---
title: "4.7.1 重複提交了怎麼辦——冪等性設計：重複請求的安全處理"
typora-root-url: ../../public
---

# 4.7.1 重複提交了怎麼辦——冪等性設計：重複請求的安全處理

### 一句話破題

冪等性讓 API 能夠安全地處理重複請求——無論調用一次還是多次，結果都一樣。

### 什麼是冪等性？

```mermaid
graph LR
    A["請求 1 次"] --> C["創建 1 個訂單"]
    B["請求 N 次"] --> C
```

**冪等操作**：多次執行和執行一次效果相同

- `GET /users/1` - 天然冪等
- `PUT /users/1` - 天然冪等
- `DELETE /users/1` - 天然冪等
- `POST /orders` - **非冪等！** 需要特殊處理

### 爲什麼需要冪等性？

1. **網絡抖動**：請求超時後重試
2. **用戶行爲**：快速雙擊提交按鈕
3. **消息隊列**：消息重複消費
4. **服務重試**：微服務調用失敗重試

### 實現冪等的核心：冪等鍵

```typescript
// 前端生成冪等鍵
const idempotencyKey = crypto.randomUUID()

fetch('/api/orders', {
  method: 'POST',
  headers: {
    'X-Idempotency-Key': idempotencyKey
  },
  body: JSON.stringify(orderData)
})
```

```typescript
// 後端處理冪等鍵
// app/api/orders/route.ts
export async function POST(request: Request) {
  const idempotencyKey = request.headers.get('X-Idempotency-Key')
  
  if (!idempotencyKey) {
    return Response.json(
      { error: '缺少冪等鍵' },
      { status: 400 }
    )
  }
  
  // 檢查是否已處理過
  const existing = await prisma.idempotencyRecord.findUnique({
    where: { key: idempotencyKey }
  })
  
  if (existing) {
    // 返回之前的結果
    return Response.json(existing.response)
  }
  
  // 創建訂單
  const order = await prisma.$transaction(async (tx) => {
    const order = await tx.order.create({
      data: orderData
    })
    
    // 記錄冪等鍵和響應
    await tx.idempotencyRecord.create({
      data: {
        key: idempotencyKey,
        response: order,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24小時後過期
      }
    })
    
    return order
  })
  
  return Response.json(order)
}
```

### 冪等記錄模型

```prisma
model IdempotencyRecord {
  id        String   @id @default(cuid())
  key       String   @unique
  response  Json
  createdAt DateTime @default(now())
  expiresAt DateTime
  
  @@index([expiresAt])
}
```

### 使用數據庫唯一約束

對於某些場景，可以利用數據庫唯一約束實現冪等：

```prisma
model Payment {
  id            String @id @default(cuid())
  orderId       String
  transactionNo String @unique // 唯一交易號
  amount        Float
  
  order Order @relation(fields: [orderId], references: [id])
}
```

```typescript
async function processPayment(orderId: string, transactionNo: string) {
  try {
    return await prisma.payment.create({
      data: {
        orderId,
        transactionNo,
        amount: 100
      }
    })
  } catch (error) {
    if (error.code === 'P2002') {
      // 唯一約束衝突 = 重複請求
      return prisma.payment.findUnique({
        where: { transactionNo }
      })
    }
    throw error
  }
}
```

### 使用 upsert 實現冪等

```typescript
async function updateUserProfile(userId: string, data: ProfileData) {
  return prisma.profile.upsert({
    where: { userId },
    update: data,
    create: { userId, ...data }
  })
}
```

### 前端防重複提交

```typescript
// 使用 React Hook 防止重複提交
function useSubmit() {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const idempotencyKeyRef = useRef<string>()
  
  const submit = async (data: FormData) => {
    if (isSubmitting) return
    
    setIsSubmitting(true)
    idempotencyKeyRef.current = crypto.randomUUID()
    
    try {
      const response = await fetch('/api/orders', {
        method: 'POST',
        headers: {
          'X-Idempotency-Key': idempotencyKeyRef.current
        },
        body: JSON.stringify(data)
      })
      return response.json()
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return { submit, isSubmitting }
}
```

### 清理過期記錄

```typescript
// 定期清理過期的冪等記錄
async function cleanupIdempotencyRecords() {
  await prisma.idempotencyRecord.deleteMany({
    where: {
      expiresAt: { lt: new Date() }
    }
  })
}
```

### 本節小結

- 冪等性保證重複請求不會產生副作用
- 使用冪等鍵（Idempotency Key）是最通用的方案
- 數據庫唯一約束可以作爲簡單場景的兜底
- 前後端配合才能完整實現冪等
