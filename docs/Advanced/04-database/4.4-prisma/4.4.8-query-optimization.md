---
title: "4.4.8 查詢如何更高效——高級查詢技巧：關聯查詢與性能優化"
typora-root-url: ../../public
---

# 4.4.8 查詢如何更高效——高級查詢技巧：關聯查詢與性能優化

### 一句話破題

Prisma 查詢優化的核心是減少查詢次數和返回數據量——學會這些技巧能讓你的應用快 10 倍。

### 避免 N+1 問題

**問題代碼**：

```typescript
// N+1 問題：100 個用戶會產生 101 次查詢
const users = await prisma.user.findMany()
for (const user of users) {
  const posts = await prisma.post.findMany({
    where: { authorId: user.id }
  })
}
```

**解決方案：使用 include**

```typescript
// 只有 1 次查詢
const users = await prisma.user.findMany({
  include: { posts: true }
})
```

### select vs include

| 方法 | 作用 | 場景 |
|------|------|------|
| `include` | 加載關聯數據 | 需要完整的關聯對象 |
| `select` | 選擇特定字段 | 只需要部分字段 |

```typescript
// include：返回所有字段 + 關聯數據
const user = await prisma.user.findUnique({
  where: { id },
  include: { posts: true }
})

// select：只返回需要的字段
const user = await prisma.user.findUnique({
  where: { id },
  select: {
    id: true,
    name: true,
    posts: {
      select: { id: true, title: true }
    }
  }
})
```

### 條件查詢技巧

**複雜條件**：

```typescript
const posts = await prisma.post.findMany({
  where: {
    AND: [
      { status: 'PUBLISHED' },
      { authorId: userId }
    ],
    OR: [
      { title: { contains: keyword } },
      { content: { contains: keyword } }
    ],
    NOT: { deletedAt: { not: null } }
  }
})
```

**動態條件構建**：

```typescript
function buildFilter(params: {
  status?: string
  authorId?: string
  keyword?: string
}) {
  const where: Prisma.PostWhereInput = {}
  
  if (params.status) {
    where.status = params.status
  }
  if (params.authorId) {
    where.authorId = params.authorId
  }
  if (params.keyword) {
    where.OR = [
      { title: { contains: params.keyword } },
      { content: { contains: params.keyword } }
    ]
  }
  
  return where
}

const posts = await prisma.post.findMany({
  where: buildFilter({ status: 'PUBLISHED', keyword: 'prisma' })
})
```

### 分頁最佳實踐

**Offset 分頁**（簡單但大數據量時慢）：

```typescript
const posts = await prisma.post.findMany({
  skip: (page - 1) * pageSize,
  take: pageSize,
  orderBy: { createdAt: 'desc' }
})

const total = await prisma.post.count()
```

**Cursor 分頁**（性能更好）：

```typescript
const posts = await prisma.post.findMany({
  take: pageSize,
  skip: cursor ? 1 : 0,  // 跳過 cursor 本身
  cursor: cursor ? { id: cursor } : undefined,
  orderBy: { id: 'asc' }
})

const nextCursor = posts.length === pageSize 
  ? posts[posts.length - 1].id 
  : null
```

### 批量操作優化

**批量創建**：

```typescript
// 使用 createMany 而非循環 create
await prisma.user.createMany({
  data: users,
  skipDuplicates: true
})
```

**批量更新**：

```typescript
await prisma.post.updateMany({
  where: { status: 'DRAFT', createdAt: { lt: oneMonthAgo } },
  data: { status: 'ARCHIVED' }
})
```

**批量刪除**：

```typescript
await prisma.post.deleteMany({
  where: { authorId: userId }
})
```

### 開啓查詢日誌

```typescript
const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' }
  ]
})

prisma.$on('query', (e) => {
  console.log(`Query: ${e.query}`)
  console.log(`Duration: ${e.duration}ms`)
})
```

### 性能優化檢查清單

| 問題 | 解決方案 |
|------|----------|
| N+1 查詢 | 使用 `include` 或 `select` |
| 返回數據過多 | 使用 `select` 只選需要的字段 |
| 分頁性能差 | 使用 Cursor 分頁替代 Offset |
| 查詢太慢 | 檢查是否缺少索引 |
| 批量操作慢 | 使用 `createMany`/`updateMany` |

### 使用原生 SQL

當 Prisma API 無法滿足需求時：

```typescript
// 原生查詢
const result = await prisma.$queryRaw`
  SELECT u.*, COUNT(p.id) as post_count
  FROM users u
  LEFT JOIN posts p ON p.author_id = u.id
  GROUP BY u.id
  ORDER BY post_count DESC
  LIMIT 10
`

// 原生執行（無返回值）
await prisma.$executeRaw`
  UPDATE posts SET view_count = view_count + 1 WHERE id = ${postId}
`
```

### 本節小結

- 使用 `include` 避免 N+1 問題
- 使用 `select` 減少返回數據量
- 大數據量分頁使用 Cursor 而非 Offset
- 批量操作使用 `createMany`/`updateMany`
- 開啓日誌排查慢查詢
