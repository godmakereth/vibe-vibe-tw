---
title: "3.5.4 上下文管理：讓 AI 記住你說過的話"
---

# 3.5.4 上下文管理：讓 AI 記住你說過的話

## 經過本節學習，你將掌握

- 理解 AI 的「記憶」是如何工作的
- 識別上下文「溢出」的信號
- 四個實用的上下文管理技巧
- 使用工具級配置讓 AI「自動記住」項目規範

## AI 的「記憶」是如何工作的

先來理解一個關鍵概念：AI 並沒有真正的「記憶」。

每次你和 AI 對話時，AI 看到的是**整個對話歷史**。就像你把一疊紙遞給一個人，讓他讀完後回答問題。紙越多，他需要處理的信息就越多。

這疊「紙」有個名字：**上下文窗口**。

### 用「工作臺」來理解

想象 AI 的上下文窗口是一張工作臺：

```
┌────────────────────────────────────────────┐
│                 AI 的工作臺                 │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐      │
│  │ 第1輪 │ │ 第2輪 │ │ 第3輪 │ │ 第4輪 │ ... │
│  │ 對話  │ │ 對話  │ │ 對話  │ │ 對話  │      │
│  └──────┘ └──────┘ └──────┘ └──────┘      │
│                                            │
│  工作臺大小有限（如 128K tokens）           │
└────────────────────────────────────────────┘
```

**工作臺的特點**：
- 大小有限（不同模型不同，通常 8K-200K tokens）
- 放不下時，**最早的內容會被「擠出去」**
- 被擠出去的內容，AI 就「忘記」了

### 不同模型的上下文窗口大小

| 模型 | 上下文窗口 | 大約相當於 |
|-----|-----------|-----------|
| GPT-4o | 128K tokens | 約 300 頁文檔 |
| Claude 3.5 Sonnet | 200K tokens | 約 500 頁文檔 |
| DeepSeek | 64K tokens | 約 150 頁文檔 |
| 較老的模型 | 4K-8K tokens | 約 10-20 頁文檔 |

看起來很大？但在長對話中，消耗速度比你想象的快。

## 上下文「溢出」的信號

當對話太長，早期內容被擠出上下文窗口時，就會出現「溢出」。

### 常見症狀

| 症狀 | 表現 | 原因 |
|-----|------|------|
| AI 突然「失憶」 | 忘記之前約定的技術棧或命名規範 | 早期對話被擠出 |
| 開始「自相矛盾」 | 前後回答不一致 | 只看到部分歷史 |
| 重複問你問過的問題 | "請問你用的是什麼框架？"（之前說過了） | 那部分對話已不在窗口內 |
| 代碼風格突變 | 之前用 TypeScript，突然開始寫 JavaScript | 忘記了技術棧約定 |

### 一個真實場景

```
第 1 輪：你說"請用 TypeScript 和 Tailwind"
第 2 輪：AI 用 TypeScript 寫代碼
第 3 輪：繼續用 TypeScript
...
第 15 輪：你讓 AI 寫一個新組件
第 16 輪：AI 突然給你 JavaScript 代碼 ← 問題出現
```

這就是上下文溢出。第 1 輪的約定已經被擠出工作臺了。

## 四個上下文管理技巧

### 技巧一：關鍵信息置頂

在每輪對話開始時，重申關鍵約定。

```markdown
繼續我們的待辦清單項目。

提醒：
- 技術棧：React + TypeScript + Tailwind
- 命名規範：組件用 PascalCase，函數用 camelCase
- 所有函數需要類型聲明

現在請幫我實現 [新功能]...
```

**效果**：關鍵信息始終在 AI 的「視野」中。

### 技巧二：定期總結

當對話進行到 10 輪以上時，主動讓 AI 總結已完成的工作。

```markdown
我們已經聊了很多輪。請總結一下目前的項目狀態：
1. 已完成的功能
2. 使用的技術棧和約定
3. 待完成的功能

然後我們繼續開發。
```

**效果**：
- 把散落在各處的信息「壓縮」成一段總結
- 總結在最新位置，不會被擠出
- 你也可以確認 AI 的理解是否正確

### 技巧三：分塊傳遞

不要一次性發送大量信息。分成多個小塊，每塊確認 AI 理解後再繼續。

```
❌ 錯誤做法：
一次性發送 3000 字的需求文檔

✅ 正確做法：
第一條消息："我要做一個待辦清單應用，先來定義核心數據結構..."
等 AI 回覆確認後
第二條消息："數據結構定好了，接下來是主要功能列表..."
```

**效果**：
- 每塊信息都得到充分處理
- 減少 AI 遺漏信息的概率
- 便於及時發現理解偏差

### 技巧四：約定重申

在關鍵節點重申重要約定，尤其是：
- 開始新功能時
- 發現 AI 偏離約定時
- 對話超過 10 輪時

```markdown
開始新功能之前，確認一下我們的約定：
1. 使用 TypeScript，不使用 any 類型
2. 組件放在 src/components 目錄
3. 狀態管理使用 useState，複雜狀態用 useReducer
4. 錯誤處理使用 try-catch

確認後，請開始實現 [功能]。
```

## 上下文管理實用模板

### 對話開始時的上下文設定

```markdown
項目背景：
- 項目名稱：[名稱]
- 技術棧：[技術棧列表]
- 當前進度：[簡要描述]

本次任務：
[具體任務描述]

請注意以下約定：
1. [約定1]
2. [約定2]
3. [約定3]
```

### 長對話中途的「檢查點」

```markdown
暫停一下，讓我確認當前狀態：

已完成：
1. [功能1]
2. [功能2]

使用的技術/約定：
- [約定1]
- [約定2]

接下來要做：
[下一個任務]

以上理解正確嗎？確認後繼續。
```

### 約定違反時的糾正

```markdown
注意：剛纔的代碼使用了 JavaScript，但我們項目約定使用 TypeScript。

請重新生成，並確保：
1. 所有變量和函數都有類型聲明
2. 不使用 any 類型
3. 導出類型定義供其他組件使用
```

## 工具級上下文管理

除了在對話中管理上下文，主流 AI IDE 還提供了**持久化配置**功能。這些配置會在每次對話開始時自動加載，讓 AI「天生」就知道你的項目規範。

### 主流工具的配置文件對照表

| 工具 | 配置文件位置 | 功能定位 |
|------|-------------|---------|
| **Cursor** | `.cursor/rules/*.mdc` | 項目規範、編碼風格、技術棧偏好 |
| **Windsurf** | `.windsurf/rules/*.md` 或 `.windsurfrules` | 項目級 AI 行爲規則 |
| **Trae** | `.trae/project_rules.md`、`user_rules.md` | 用戶規則 + 項目規則 |
| **Claude Code** | `CLAUDE.md` + `SKILL.md` | 項目上下文 + 可複用技能 |
| **GitHub Copilot** | `.github/copilot-instructions.md` | 倉庫級指令 |
| **OpenAI Codex** | `AGENTS.md` | 代理指令文件 |
| **Factory Droid** | `.factory/droids/*.md` | 自定義 Droid 配置 |
| **Aider** | `CONVENTIONS.md` | 編碼規範文件 |
| **Cline** | `.clinerules` | 項目規則 |

### 配置文件應該寫什麼？

無論使用哪個工具，配置文件通常包含：

1. **項目概述**：這是什麼項目，解決什麼問題
2. **技術棧**：使用的語言、框架、庫
3. **編碼規範**：命名約定、代碼風格、目錄結構
4. **禁止事項**：不要使用的庫、不要採用的模式
5. **常用命令**：構建、測試、部署的命令

### 通用項目配置模板

```markdown
# 項目配置

## 項目概述
這是一個待辦清單應用，幫助用戶管理日常任務。

## 技術棧
- 前端：React 18 + TypeScript 5
- 樣式：Tailwind CSS 3
- 狀態管理：Zustand
- 測試：Vitest

## 目錄結構
- src/components：React 組件
- src/hooks：自定義 Hooks
- src/utils：工具函數
- src/types：TypeScript 類型定義

## 編碼規範
- 使用函數式組件，不用 class 組件
- 所有函數必須有 TypeScript 類型聲明
- 組件文件使用 PascalCase 命名
- 工具函數使用 camelCase 命名
- 使用中文註釋

## 禁止事項
- 不要使用 `any` 類型
- 不要使用 jQuery
- 不要在組件中直接寫內聯樣式（使用 Tailwind）
- 不要使用 `var`，使用 `const` 或 `let`

## 常用命令
- 開發：npm run dev
- 構建：npm run build
- 測試：npm test
```

### 爲什麼配置文件很重要？

| 沒有配置文件 | 有配置文件 |
|-------------|-----------|
| 每次對話都要重複說技術棧 | AI 自動知道技術棧 |
| AI 可能用錯誤的規範 | 規範始終一致 |
| 團隊成員各自配置不同 | 團隊共享同一份配置 |
| 約定容易被遺忘 | 約定被版本控制 |

> **提示**：具體工具的詳細配置方法，請參考各工具的官方文檔。基礎版只需瞭解這些功能存在即可，進階版會有更詳細的工具配置教程。

## 本節要點

✓ **AI 無真正記憶**：它看到的是對話歷史，歷史太長會「溢出」

✓ **溢出信號**：AI 失憶、自相矛盾、代碼風格突變

✓ **四個管理技巧**：關鍵信息置頂、定期總結、分塊傳遞、約定重申

✓ **工具級配置**：用配置文件讓 AI 自動加載項目規範

✓ **團隊協作**：配置文件可納入版本控制，團隊共享

下一節，我們來學習什麼時候應該放棄舊對話，開始一個全新的對話。
