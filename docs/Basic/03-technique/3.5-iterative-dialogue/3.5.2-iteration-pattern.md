---
title: "3.5.2 迭代對話的基本模式"
---

# 3.5.2 迭代對話的基本模式

## 經過本節學習，你將掌握

- 三階段迭代模型：看方向 → 改問題 → 磨細節
- 每一輪對話的關鍵動作和檢查點
- 一個完整的迭代對話示例（小李的待辦清單）
- 可直接複製使用的迭代對話模板

## 三階段迭代模型

迭代對話不是漫無目的地來回修改。高效的迭代遵循一個清晰的模式：

```
第一輪：看方向
    ↓
  方向對嗎？整體思路對嗎？
    ↓
第二輪：改問題
    ↓
  功能完整嗎？有沒有明顯缺陷？
    ↓
第三輪：磨細節
    ↓
  代碼結構好嗎？有沒有邊界情況？
    ↓
  完成
```

### 第一輪：看方向

**目標**：確認 AI 理解了你的意圖，整體方向正確。

**關鍵動作**：
- 提出核心需求，不要糾結細節
- 明確告訴 AI「先給我一個基礎實現」
- 重點看：AI 的理解對不對？大方向對不對？

**檢查點**：
- [ ] AI 做的是你想要的功能嗎？
- [ ] 技術方案和你預期一致嗎？
- [ ] 如果方向錯了，現在就要糾正

**常見問題**：方向錯誤。比如你想要一個彈窗，AI 給你做了一個新頁面。

### 第二輪：改問題

**目標**：修正第一輪的明顯問題，補充遺漏的功能。

**關鍵動作**：
- 指出具體問題，不要說「不太對」
- 列出需要添加的功能點
- 可以一次提多個修改，但不要超過 3-5 個

**檢查點**：
- [ ] 核心功能都實現了嗎？
- [ ] 交互邏輯正確嗎？
- [ ] 有沒有明顯的 bug？

**常見問題**：功能缺失或邏輯錯誤。比如缺少輸入驗證，或者按鈕點擊沒反應。

### 第三輪：磨細節

**目標**：優化代碼結構，處理邊界情況，提升質量。

**關鍵動作**：
- 關注代碼的可維護性
- 檢查邊界情況（空輸入、超長輸入、特殊字符）
- 優化命名、註釋、結構

**檢查點**：
- [ ] 代碼結構清晰嗎？
- [ ] 邊界情況處理了嗎？
- [ ] 代碼可以直接用於生產嗎？

**常見問題**：代碼能用但不夠好。比如邏輯全寫在一個函數里，或者沒有錯誤處理。

## 完整案例：小李的「添加任務」功能

讓我們看小李如何用三階段模型，迭代出一個滿意的添加任務功能。

### 第一輪對話：看方向

**小李的提示詞：**
```
我正在開發一個待辦清單應用，使用 React + TypeScript + Tailwind CSS。

請幫我實現「添加任務」功能：
- 一個輸入框 + 一個添加按鈕
- 點擊按鈕可以添加任務到列表

先給我一個基礎實現，後續再完善。
```

**AI 的輸出：**
```tsx
import { useState } from 'react';

interface Task {
  id: number;
  title: string;
}

export default function AddTaskForm() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [inputValue, setInputValue] = useState('');

  const handleAdd = () => {
    const newTask: Task = {
      id: Date.now(),
      title: inputValue,
    };
    setTasks([...tasks, newTask]);
    setInputValue('');
  };

  return (
    <div>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        className="border p-2"
      />
      <button onClick={handleAdd} className="bg-blue-500 text-white p-2 ml-2">
        添加
      </button>
      <ul>
        {tasks.map((task) => (
          <li key={task.id}>{task.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

**小李的檢查**：
- ✅ 方向對：輸入框 + 按鈕 + 任務列表
- ✅ 技術棧對：React + TypeScript + Tailwind
- ⚠️ 但有問題：沒有輸入驗證，可以添加空任務

**判斷**：方向正確，進入第二輪。

### 第二輪對話：改問題

**小李的提示詞：**
```
基礎功能可以了，請加上以下改進：

1. 支持按回車鍵添加任務（不只是點擊按鈕）
2. 添加空輸入驗證：
   - 輸入爲空時，按鈕顯示爲禁用狀態
   - 嘗試添加空任務時，不執行任何操作
3. 輸入框添加 placeholder："輸入新任務..."
```

**AI 的輸出：**
```tsx
import { useState } from 'react';

interface Task {
  id: number;
  title: string;
}

export default function AddTaskForm() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [inputValue, setInputValue] = useState('');

  const isInputEmpty = inputValue.trim() === '';

  const handleAdd = () => {
    if (isInputEmpty) return;
    
    const newTask: Task = {
      id: Date.now(),
      title: inputValue.trim(),
    };
    setTasks([...tasks, newTask]);
    setInputValue('');
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleAdd();
    }
  };

  return (
    <div>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="輸入新任務..."
        className="border p-2 rounded"
      />
      <button
        onClick={handleAdd}
        disabled={isInputEmpty}
        className={`p-2 ml-2 rounded ${
          isInputEmpty
            ? 'bg-gray-300 cursor-not-allowed'
            : 'bg-blue-500 text-white hover:bg-blue-600'
        }`}
      >
        添加
      </button>
      <ul className="mt-4">
        {tasks.map((task) => (
          <li key={task.id} className="py-1">{task.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

**小李的檢查**：
- ✅ 回車添加：已實現
- ✅ 空輸入驗證：已實現
- ✅ placeholder：已添加
- ⚠️ 代碼結構問題：驗證邏輯和 UI 邏輯混在一起

**判斷**：功能完整，進入第三輪優化結構。

### 第三輪對話：磨細節

**小李的提示詞：**
```
功能完整了，請優化代碼結構：

1. 把輸入驗證邏輯抽成獨立函數 validateTaskInput
2. 把樣式類名用常量統一管理（方便後續修改）
3. 添加必要的註釋說明組件用途
```

**AI 的最終輸出：**
```tsx
import { useState } from 'react';

// 任務數據類型
interface Task {
  id: number;
  title: string;
}

// 樣式常量
const STYLES = {
  input: 'border p-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-300',
  buttonBase: 'p-2 ml-2 rounded transition-colors',
  buttonEnabled: 'bg-blue-500 text-white hover:bg-blue-600',
  buttonDisabled: 'bg-gray-300 cursor-not-allowed text-gray-500',
  taskItem: 'py-1 border-b border-gray-100',
};

// 驗證任務輸入
function validateTaskInput(input: string): boolean {
  return input.trim().length > 0;
}

/**
 * 添加任務表單組件
 * 功能：輸入框 + 添加按鈕，支持回車添加，包含空輸入驗證
 */
export default function AddTaskForm() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [inputValue, setInputValue] = useState('');

  const isValid = validateTaskInput(inputValue);

  const handleAdd = () => {
    if (!isValid) return;
    
    const newTask: Task = {
      id: Date.now(),
      title: inputValue.trim(),
    };
    setTasks([...tasks, newTask]);
    setInputValue('');
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleAdd();
    }
  };

  return (
    <div className="p-4">
      <div className="flex">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="輸入新任務..."
          className={STYLES.input}
        />
        <button
          onClick={handleAdd}
          disabled={!isValid}
          className={`${STYLES.buttonBase} ${
            isValid ? STYLES.buttonEnabled : STYLES.buttonDisabled
          }`}
        >
          添加
        </button>
      </div>
      <ul className="mt-4">
        {tasks.map((task) => (
          <li key={task.id} className={STYLES.taskItem}>
            {task.title}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**小李的檢查**：
- ✅ 驗證邏輯獨立：`validateTaskInput` 函數
- ✅ 樣式統一管理：`STYLES` 常量
- ✅ 註釋清晰：組件用途說明
- ✅ 代碼可維護：結構清晰，易於擴展

**結果**：三輪對話，從「能用」到「好用」。

## 每輪對話的行動清單

| 階段 | 你的重點 | 提示詞關鍵詞 | 檢查什麼 |
|-----|---------|------------|---------|
| 第一輪 | 看方向 | "基礎實現"、"先給我一個..." | 方向對不對？理解對不對？ |
| 第二輪 | 改問題 | "請加上..."、"修正..." | 功能完整嗎？邏輯對嗎？ |
| 第三輪 | 磨細節 | "優化結構"、"抽成函數" | 代碼好維護嗎？邊界情況？ |

## 可複製模板：迭代對話腳本

### 第一輪模板：建立方向

```markdown
我正在開發 [項目名稱]，使用 [技術棧]。

請幫我實現 [功能名稱]：
- [核心需求1]
- [核心需求2]

先給我一個基礎實現，我們後續再逐步完善。
```

### 第二輪模板：修正問題

```markdown
基礎功能可以了，請加上以下改進：

1. [需要添加的功能/修正的問題]
2. [需要添加的功能/修正的問題]
3. [需要添加的功能/修正的問題]
```

### 第三輪模板：優化細節

```markdown
功能完整了，請優化代碼：

1. [結構優化要求]
2. [邊界情況處理]
3. [其他質量要求]
```

## 什麼時候可以跳過某個階段？

| 情況 | 可以跳過 | 原因 |
|-----|---------|------|
| 任務非常簡單 | 第三輪 | 代碼量小，不需要結構優化 |
| 第一輪輸出已經很好 | 第二輪 | 直接進入細節打磨 |
| 只是快速原型驗證 | 第三輪 | 後續會重寫，不需要完美 |

## 迭代次數的經驗值

| 任務複雜度 | 典型迭代次數 | 示例 |
|-----------|-------------|------|
| 簡單（單一功能） | 1-2 輪 | 一個按鈕、一個輸入框 |
| 中等（多個功能） | 2-3 輪 | 一個表單、一個列表組件 |
| 複雜（完整模塊） | 3-5 輪 | 一個完整頁面、一個複雜交互 |

如果超過 5 輪還沒達到滿意效果，考慮是不是需求本身不夠清晰，或者應該開始新對話。

## 本節要點

✓ **三階段模型**：看方向 → 改問題 → 磨細節

✓ **每輪有焦點**：第一輪不糾結細節，第二輪不糾結結構，第三輪專注質量

✓ **明確檢查點**：每輪結束都有清晰的檢查標準

✓ **靈活調整**：簡單任務可以跳過階段，複雜任務可能需要更多輪次

下一節，我們來學習如何給 AI 有效的反饋——這是迭代成功的關鍵。
