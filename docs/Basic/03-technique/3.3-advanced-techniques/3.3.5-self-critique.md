---
title: "3.3.5 Self-Critique：讓 AI 自我檢查"
---

# 3.3.5 Self-Critique：讓 AI 自我檢查

## 經過本節學習，你將掌握

- Self-Critique（自我批評）的定義和原理
- 爲什麼 AI 自查能提升輸出質量
- 自查的核心維度清單
- 如何在提示詞中引導 AI 自查
- Self-Critique 的侷限性

## 什麼是 Self-Critique

Self-Critique（自我批評）的核心思想是：**讓 AI 生成內容後，再自己檢查一遍，發現並修正問題**。

這就像寫完文章後自己校對一遍，往往能發現最初遺漏的錯誤。

```
生成 → 自查 → 修正
```

## 核心洞見：爲什麼自查有效

> "SELF-REFINE 方法可以在無需額外訓練的情況下，將 AI 輸出質量提升約 20%。"
> —— 2023 年 CMU 研究論文

這個數據告訴我們：同一個 AI，加一步自查，效果就能明顯提升。

原因在於：
1. **第一次生成往往有遺漏**：AI 快速生成時可能忽略邊界情況
2. **自查時換個視角**：審查模式會關注不同方面
3. **迭代改進更精準**：基於具體問題修改，比重新生成更準確

## 自查的核心維度

不同類型的內容，需要檢查的維度不同：

### 代碼自查維度

| 維度 | 檢查內容 | 常見問題 |
|-----|---------|---------|
| **功能正確性** | 是否實現了需求 | 遺漏部分功能 |
| **邊界情況** | 空值、極值、異常輸入 | 沒處理 null/undefined |
| **安全性** | XSS、注入、敏感數據 | 用戶輸入未過濾 |
| **性能** | 時間/空間複雜度 | 不必要的循環嵌套 |
| **可讀性** | 命名、註釋、結構 | 變量名不清晰 |
| **可維護性** | 重複代碼、耦合度 | 硬編碼 magic number |

### 文案/文檔自查維度

| 維度 | 檢查內容 |
|-----|---------|
| **準確性** | 信息是否正確 |
| **完整性** | 是否遺漏關鍵點 |
| **清晰度** | 是否容易理解 |
| **一致性** | 術語、風格是否統一 |

## 差提示詞 vs 好提示詞

### 場景：生成表單驗證函數

### ❌ 差提示詞

```
寫一個驗證用戶註冊表單的函數，檢查郵箱和密碼。
```

AI 可能生成一個基礎版本，但遺漏邊界情況。

### ✅ 好提示詞（帶 Self-Critique）

```
寫一個驗證用戶註冊表單的函數，檢查郵箱和密碼。

生成後，請自查：
1. 是否覆蓋了所有邊界情況（空值、空字符串、只有空格）？
2. 是否有安全隱患（XSS、注入風險）？
3. 錯誤提示是否清晰，用戶能知道具體問題？
4. 是否有不必要的重複代碼？

如有問題，請修正後重新輸出最終版本。
```

### 好提示詞的 AI 輸出

AI 會先生成代碼，然後逐條檢查，最後給出改進版：

```javascript
// 自查發現的問題：
// 1. 原版沒有處理 trim 後爲空的情況
// 2. 錯誤提示不夠具體
// 3. 郵箱正則可以更嚴格

// 改進後的版本：
function validateRegistration(email, password) {
  const errors = [];
  
  // 處理空白字符
  const trimmedEmail = email?.trim() || '';
  const trimmedPassword = password || '';
  
  // 郵箱驗證
  if (!trimmedEmail) {
    errors.push('郵箱不能爲空');
  } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmedEmail)) {
    errors.push('郵箱格式不正確，請檢查是否包含 @ 和域名');
  }
  
  // 密碼驗證
  if (!trimmedPassword) {
    errors.push('密碼不能爲空');
  } else {
    if (trimmedPassword.length < 8) {
      errors.push('密碼長度至少 8 位');
    }
    if (!/[A-Z]/.test(trimmedPassword)) {
      errors.push('密碼需要包含至少一個大寫字母');
    }
    if (!/[0-9]/.test(trimmedPassword)) {
      errors.push('密碼需要包含至少一個數字');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}
```

## 常用自查指令詞庫

### 通用自查

```
生成後，請檢查是否有遺漏或錯誤，如有請修正。
```

### 代碼自查

```
請自查：
1. 邊界情況是否都處理了？
2. 有沒有潛在的安全問題？
3. 性能是否可以優化？
如有問題，請修正後輸出最終版本。
```

### 嚴格自查

```
請扮演一個嚴格的代碼審查者，審查你剛纔生成的代碼：
- 找出至少 3 個可以改進的地方
- 給出改進後的版本
```

### 特定維度自查

```
請從 [安全性/性能/可讀性] 角度審查這段代碼，指出問題並修正。
```

## 實戰示例：待辦清單項目

小李讓 AI 生成一個任務排序函數，並要求自查。

### Self-Critique 提示詞

```
爲我的待辦清單應用寫一個排序函數，支持按以下方式排序：
- 按創建時間（新到舊）
- 按截止日期（近到遠，無截止日期的排最後）
- 按優先級（高 > 中 > 低）

任務數據結構：
{
  id: string,
  title: string,
  createdAt: Date,
  dueDate: Date | null,
  priority: 'high' | 'medium' | 'low'
}

生成後，請自查：
1. 排序邏輯是否正確處理了 null/undefined？
2. 優先級排序的順序是否符合預期？
3. 函數接口是否清晰易用？
如有問題，請修正。
```

### AI 輸出（含自查過程）

```javascript
// 初版實現...

// 自查發現：
// 1. dueDate 爲 null 時直接比較會出問題 ✓ 已處理
// 2. 優先級用字符串比較不可靠，需要映射爲數字 → 需修正
// 3. 函數可以更靈活，支持升序/降序 → 已優化

// 最終版本：
const priorityMap = { high: 3, medium: 2, low: 1 };

function sortTasks(tasks, sortBy, order = 'desc') {
  const direction = order === 'desc' ? -1 : 1;
  
  return [...tasks].sort((a, b) => {
    switch (sortBy) {
      case 'createdAt':
        return direction * (new Date(b.createdAt) - new Date(a.createdAt));
      
      case 'dueDate':
        // null 排最後
        if (!a.dueDate && !b.dueDate) return 0;
        if (!a.dueDate) return 1;
        if (!b.dueDate) return -1;
        return direction * (new Date(a.dueDate) - new Date(b.dueDate));
      
      case 'priority':
        return direction * (priorityMap[b.priority] - priorityMap[a.priority]);
      
      default:
        return 0;
    }
  });
}
```

## 迭代式 Self-Critique

對於重要輸出，可以進行多輪自查：

```
第一輪：功能正確性檢查
第二輪：安全性檢查
第三輪：性能和代碼質量檢查
```

每輪聚焦一個維度，逐步完善。

## Self-Critique 的侷限性

| 侷限 | 表現 | 應對方法 |
|-----|------|---------|
| 自我認可偏差 | AI 可能認爲自己的輸出沒問題 | 用「扮演嚴格審查者」指令 |
| 檢查不徹底 | 可能遺漏某些維度 | 明確列出要檢查的維度 |
| 越查越亂 | 修正時引入新問題 | 限制修改範圍，一次只改一處 |
| 增加 token | 輸出變長 | 對重要輸出使用，簡單任務跳過 |

## 與人工審查的配合

Self-Critique 不能替代人工審查，而是**減輕人工審查負擔**。

推薦流程：
1. AI 生成 + 自查 → 得到初版
2. 你快速瀏覽，發現明顯問題 → 讓 AI 修正
3. 最終人工確認關鍵邏輯

## 可複製模板

### 代碼生成 + 自查模板

```markdown
[任務描述]

生成後，請自查：
1. 是否覆蓋了所有邊界情況？
2. 是否有安全隱患？
3. 代碼是否清晰可維護？
如有問題，請修正後輸出最終版本。
```

### 嚴格審查模板

```markdown
請扮演一個嚴格的 [角色：代碼審查者/編輯/QA]，審查你剛纔的輸出：
- 找出至少 [數量] 個可以改進的地方
- 說明每個問題的影響
- 給出改進後的版本
```

### 特定維度審查模板

```markdown
請從以下維度審查你的輸出：
- [ ] [維度1]
- [ ] [維度2]
- [ ] [維度3]

對每個維度，說明是否通過，如不通過請修正。
```

## 本節要點

✓ **Self-Critique 的本質**：讓 AI 生成後自我檢查，發現並修正問題

✓ **爲什麼有效**：自查時換視角，能發現第一次遺漏的問題

✓ **核心維度**：功能正確性、邊界情況、安全性、性能、可讀性

✓ **常用指令**：「請自查...如有問題請修正」「扮演嚴格審查者」

✓ **侷限性**：可能自我認可、檢查不徹底，需配合人工審查

下一節，我們學習如何選擇合適的技巧——技巧選擇指南。
