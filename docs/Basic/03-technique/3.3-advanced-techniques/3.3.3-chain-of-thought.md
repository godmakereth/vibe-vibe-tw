---
title: "3.3.3 Chain of Thought：讓 AI \"想一想\"再回答"
---

# 3.3.3 Chain of Thought：讓 AI "想一想"再回答

## 經過本節學習，你將掌握

- Chain of Thought（CoT）的定義和原理
- 兩種觸發 CoT 的方式
- CoT 真正有效的場景（基於最新研究）
- 如何寫出有效的 CoT 提示詞
- CoT 的侷限性和注意事項

## 什麼是 Chain of Thought

Chain of Thought（思維鏈，簡稱 CoT）的核心思想是：**讓 AI 把推理過程寫出來，而不是直接給答案**。

就像數學考試要求「寫出解題步驟」一樣，當 AI 被要求展示思考過程時，往往能得到更準確的答案。

```
❌ 直接問：
這個函數的時間複雜度是多少？

✅ 用 CoT：
請分析這個函數的時間複雜度。
首先，識別代碼中的循環結構；
然後，分析每個循環的執行次數；
最後，計算總的時間複雜度。
```

## 核心洞見：CoT 並非萬能

> "Chain of Thought 主要在數學和符號推理任務上有顯著效果，對其他類型任務的收益有限。"
> —— 2024 年論文《To CoT or not to CoT?》

這個研究結論很重要。它告訴我們：

| 任務類型 | CoT 效果 | 原因 |
|---------|---------|------|
| 數學計算 | ✅ 顯著提升 | 需要多步推理，步驟分解有幫助 |
| 邏輯推理 | ✅ 明顯提升 | 複雜邏輯需要逐步梳理 |
| 代碼分析 | ✅ 有幫助 | 涉及多層嵌套和條件判斷 |
| 文本生成 | ⚠️ 收益有限 | 創意任務不需要嚴格推理 |
| 簡單分類 | ❌ 可能更慢 | 增加不必要的步驟 |

**實踐建議**：不要對所有任務都用 CoT，只在需要推理的場景使用。

## 兩種觸發方式

### 方式一：魔法咒語

最簡單的方式，只需在提示詞末尾加一句話：

```
請分析這段代碼的性能瓶頸。
Let's think step by step.
```

或者中文版：

```
請分析這段代碼的性能瓶頸。
讓我們一步一步來思考。
```

這種方式簡單，但 AI 的推理步驟可能不夠結構化。

### 方式二：顯式步驟分解

更可控的方式，直接告訴 AI 該怎麼分步：

```
請分析這段代碼的性能瓶頸。

分析步驟：
1. 首先，識別代碼中的循環和遞歸結構
2. 然後，找出可能的重複計算
3. 接着，檢查數據結構的選擇是否合理
4. 最後，給出優化建議及預期效果
```

這種方式的輸出更結構化，適合需要特定分析角度的場景。

## 差提示詞 vs 好提示詞

### 場景：分析表單驗證邏輯

### ❌ 差提示詞

```
這個表單驗證邏輯有問題嗎？

function validateForm(data) {
  if (data.email && data.password && data.password.length >= 6) {
    if (data.email.includes('@')) {
      return true;
    }
  }
  return false;
}
```

**問題**：AI 可能只給一個籠統的結論，遺漏一些邊界情況。

### ✅ 好提示詞（使用 CoT）

```
請審查這個表單驗證函數，檢查是否有遺漏的驗證場景。

function validateForm(data) {
  if (data.email && data.password && data.password.length >= 6) {
    if (data.email.includes('@')) {
      return true;
    }
  }
  return false;
}

分析步驟：
1. 首先，列出這個函數當前檢查了哪些條件
2. 然後，思考常見的表單驗證需要檢查什麼
3. 接着，對比找出遺漏的驗證項
4. 最後，給出改進建議
```

### 好提示詞的 AI 輸出

```
分析過程：

1. 當前檢查的條件：
   - email 存在且非空
   - password 存在且非空
   - password 長度 >= 6
   - email 包含 @ 符號

2. 常見表單驗證需要檢查：
   - email 格式完整性（@前後都要有內容，要有域名後綴）
   - password 強度（大小寫、數字、特殊字符）
   - 防止 SQL 注入和 XSS
   - 空白字符處理

3. 遺漏的驗證項：
   - email 格式不完整："@" 或 "a@" 或 "@b" 都能通過
   - password 只檢查長度，沒檢查強度
   - 沒有處理首尾空格
   - 沒有驗證 email 的域名後綴（如 .com）

4. 改進建議：
   - 使用正則表達式驗證 email 格式
   - 添加密碼強度檢查
   - 對輸入做 trim() 處理
```

## 適用場景決策表

| 場景 | 是否使用 CoT | 理由 |
|-----|------------|------|
| 計算時間/空間複雜度 | ✅ 使用 | 需要分析循環嵌套 |
| 審查代碼邏輯 | ✅ 使用 | 需要考慮多個分支和邊界 |
| 設計數據庫表結構 | ✅ 使用 | 需要分析實體關係 |
| 調試錯誤原因 | ✅ 使用 | 需要逐步排查 |
| 簡單代碼格式轉換 | ❌ 不用 | 直接轉換即可 |
| 寫一段文案 | ❌ 不用 | 創意任務不需要嚴格推理 |
| 重命名變量 | ❌ 不用 | 任務過於簡單 |

## 實戰示例：待辦清單項目

小李想讓 AI 幫他分析一個 Bug：任務刪除後，有時候頁面沒有更新。

### CoT 提示詞

```
我的待辦清單應用有一個 Bug：刪除任務後，頁面有時候不更新。

以下是相關代碼：

// 任務列表狀態
const [tasks, setTasks] = useState([]);

// 刪除任務
const deleteTask = (id) => {
  tasks.splice(tasks.findIndex(t => t.id === id), 1);
  setTasks(tasks);
}

請幫我分析問題原因。

分析步驟：
1. 首先，理解 React 狀態更新的機制
2. 然後，檢查這段代碼的狀態更新方式
3. 接着，找出導致不更新的原因
4. 最後，給出修復方案
```

### AI 輸出

```
分析過程：

1. React 狀態更新機制：
   React 通過對比新舊狀態的引用來決定是否重新渲染。
   如果狀態對象的引用沒變，React 認爲狀態沒有改變。

2. 當前代碼的問題：
   - splice() 直接修改了原數組
   - setTasks(tasks) 傳入的還是同一個數組引用
   - React 對比發現引用相同，不觸發重新渲染

3. 問題根因：
   直接修改原數組（mutation）而非創建新數組（immutation）

4. 修復方案：
   使用 filter 創建新數組：
   
   const deleteTask = (id) => {
     setTasks(tasks.filter(t => t.id !== id));
   }

   或者使用展開運算符：
   
   const deleteTask = (id) => {
     const newTasks = [...tasks];
     newTasks.splice(newTasks.findIndex(t => t.id === id), 1);
     setTasks(newTasks);
   }
```

## Concise CoT：簡潔版

如果你希望節省 token，可以用簡潔版 CoT：

```
請簡要分析這個函數的時間複雜度，用 2-3 句話說明推理過程，然後給出結論。
```

研究表明，Concise CoT 可以減少約 50% 的輸出長度，同時保持大部分推理準確性。

## CoT 的侷限性

| 侷限 | 表現 | 應對方法 |
|-----|------|---------|
| 增加輸出長度 | Token 消耗增加 20-80% | 用 Concise CoT 或限制字數 |
| 某些任務反而變差 | 簡單任務強行分步可能出錯 | 根據場景選擇是否使用 |
| 推理可能出錯 | 某一步錯了，後續全錯 | 配合 Self-Critique 檢查 |

## 可複製模板

### 代碼分析 CoT 模板

```markdown
請分析以下代碼的 [分析目標：性能/安全性/可維護性]：

[代碼]

分析步驟：
1. 首先，[第一步分析角度]
2. 然後，[第二步分析角度]
3. 接着，[第三步分析角度]
4. 最後，給出結論和建議
```

### 問題排查 CoT 模板

```markdown
問題描述：[問題現象]

相關代碼/配置：
[代碼或配置]

請幫我分析問題原因。

排查步驟：
1. 首先，理解正常情況下應該如何工作
2. 然後，檢查當前代碼的執行流程
3. 接着，定位可能導致問題的環節
4. 最後，給出修復方案
```

### 簡潔 CoT 模板

```markdown
請分析 [任務]。
用 2-3 句話說明你的推理過程，然後給出結論。
```

## 本節要點

✓ **CoT 的本質**：讓 AI 展示推理過程，而非直接給答案

✓ **有效場景**：數學計算、邏輯推理、代碼分析、問題排查

✓ **兩種觸發方式**：魔法咒語（簡單）vs 顯式步驟分解（可控）

✓ **不要濫用**：簡單任務不需要 CoT，反而會降低效率

✓ **Concise CoT**：在需要節省 token 時使用簡潔版

下一節，我們學習如何讓 AI 探索多條路徑——Tree of Thoughts。
